{
  "transpiled": true,
  "noir_version": "1.0.0-beta.1+2d73c1d7bc5b1db7",
  "name": "RockPaperScissors",
  "functions": [
    {
      "name": "_add_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "4255801969160781417": {
            "error_kind": "string",
            "string": "Function _add_game can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "sender",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "game_note",
            "type": {
              "fields": [
                {
                  "name": "id",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "bet_amount",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "token_address",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "is_completed",
                  "type": {
                    "kind": "boolean"
                  }
                },
                {
                  "name": "blocktime",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "player2_address",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "player2_move",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "game_note::GameNote"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_add_game"
      ]
    },
    {
      "name": "get_timeout_blocks",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAB5HgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAaSQAAACiJgIBAAYuDAABAAIsDAIBJScAgAQEeAANAAAAgASAAyMAgAMAAAChKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlLQAYyhjK",
      "debug_symbols": "5ZTLboMwEEX/xWsv/MJj51eqKuJhIksIEI9KFeLfOyBMKUHJhnSTDXisY9/r8XgGkrmkv119mVctuXwMpKjSuPNVidEwUpI0vij87bqdJmz6aDvzbR2XU9h2cdORC9eWUeLKDIfAGO6Q+8KRi5YjvYcZiwLMRLTCfFp4Ryulw9Y4tCsN4gA2UooFNlKZLfxJCagTvJsgwNH8P3o/I++Kr3nXz/LOI1CB1pI99m4VNwtsleY77wZO9c7ZX++oYMWrFfD3eonoSMJIZte6kPqJhOAQJITa1Gd0dMegWLhjUJuXeHjHwG14tiCkegzj+WBNDAZyVxI49SZnHTH6ihsfJ4Vbumvel+mm2Xbftdv13bqpUpf1jZs68G/znZMmBBUwp3AKDJUMNVDnBw==",
      "brillig_names": [
        "get_timeout_blocks"
      ]
    },
    {
      "name": "set_timeout_blocks",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "3295174574362609801": {
            "error_kind": "string",
            "string": "Only owner can set timeout blocks"
          }
        },
        "parameters": [
          {
            "name": "new_timeout",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgIEASYCAwQAHxgAAwACgEMtCIBDAAEkAAAAQCcCAAEEgEQmAgIEADoNAAEAAiQAAACXHgIAAgAeAgADADI4AAIAAwAEJgICAQEjAgAEAAAAaSQAAADAHgIAAgEmAgMABS4MAAMABAo4AgQDIwIAAwAAAIskAAAA0iYCAgAGLwwAAQACJScAgAQEeAANAAAAgASAAyMAgAMAAAC/KQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlKQEAAQUtus/RGchIiTsBAQIlLQAYyhjK",
      "debug_symbols": "5VbbisIwEP2XPPchmUxmEn9lWZaqVQqlSq0Li/jvOy0mdmuxILovvrSdcpJz5sqc1LpYHrdfZb3ZHdTi46Sq3Spvy10t1umcqWVTVlW5/Rr+Vrp7UOjxh31ed+ahzZtWLQwFnamiXssnay03bMqqUAuy5+wWrLWLYA0ugU138AaNSPFq+QwJzTAB9tbCBewt+iH4M1OMT9DuI4ER8f+o/RlxR5PiTnNxN44xosnq+9oDGn8BByQz0u75qdqN/qtdGAK8mkFer6dwkxTBpJILdoYCycasISHMVVwIseLQ4ChrInFajqUkx+F9OQAUPQbwdPUYwwSaUUfxjIPBMCmehT2CweJ9sPjCKU9i2Btf3fv4Cma2zBwNfe0P0QOHLD5yaHLSgU7xAm1hptFQp0ZD4Gsq3NSkY+/i8GLvZyYdUxrpzMbMpcJwSKkA0ONUIL6Jr2exvvOmzJdVcdkxNsd6NVg52p99Mdo+9s1uVayPTdHtIdcVpJ9LwJmFvnPFkC61XjiE5xc=",
      "brillig_names": [
        "set_timeout_blocks"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": {
              "kind": "boolean"
            },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 4,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": {
              "kind": "field"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "compute_note_hash_and_optionally_a_nullifier"
      ]
    },
    {
      "name": "timeout_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15733354797221546546": {
            "error_kind": "string",
            "string": "Not enough blocks have passed for timeout"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2169137763093847922": {
            "error_kind": "string",
            "string": "Player 2 hasn't played yet"
          },
          "2701317986746916850": {
            "error_kind": "string",
            "string": "Game already completed"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7Z3bjtw2EobfZa7ngqeqIvMqwcKwHScYYGAHtrPAwvC7r3o8YmuaxaZVEduqEW+C6Vh/11+fKJ7EJr/d/fHh3T9/vXn4+OenL3e//f7t7vHT+7dfHz59nD59+35/9+7zw+Pjw19vlv/7zpz+g+np+i9/v/14+vjl69vPX+9+s5jM/d2Hj39Mf5Ix0zf8+fD44e439N//c39HXqCJ6zVRECfSek2yAg2u11hjJSKQiAS31dogEUkiubV39r682BiYLzYO8sX2JCyuDgHnr57+TPlqcszF0Xv3fHH0IS4vfjIfNzAf5wh2cn9D834L8sFm8tgib4HCfDV6c918CjY+X5wC2kvzwW5qfnq0Xph/CoHdQ0DoH4J9KBESPqsQrbt8KDFIRJJIJInEtyANUXQSEQpEyUhEEhBJAMIZJxGRQGQlkawAuXNGIgoSkQS5b4Nw2HjOnaX5OXdh0U4AV9VSMHNVS2HRJLJVLRnMFy9r8R9VrfOo2DzfTmgxr5k8aCYPmsmj0Ww+aDafFJvnx/JazEfF5qPm7kEkxeaT5kYqKW6kvFHcSHl+Ik6LecWNlLeKuwfeKm6kvFPcSHmnuJHysPPaJtlsPrlL8zvvVVqav5ps9IX5mxcbH1M2HxpT5C++eunjh/nb9yq3NK+Z/O17levMQ37j5BZvVmbzqNd8MIrJh9v3KteZP7+VcildmrdGs3nN5J1m8j/xDuZXmp86jvNXe4+F+aTYvNdM3msmH/y+zSNm8wSF+ajYPGgmD5rJ474HI8Fk81NnoDC/78HIdfOkmfzOB+DXzcd9D0amdiibB1eY3/cw8Lr5nQ/AG+YVk4fKax0y8yAAyfml+ScRCETWS0R8GxohiyKFSxG/RLklkkSqLLW6LqoscUp53EXGNhaRQswXQzLhegmIiPNy64gRlxc/2WFzIBNctkN0mQO/WIisiXl21sOmZX7dLHGaM57KVAOPtYbyiHf6cDmpDPzaoteZK9/tIwvZkC0LNN/daohIEokqkRYvBVK8FEUnEUkipXZOjIjWi5CvgRsifsqPwOYnHXwqRHwkNHOrQviy2i5L3YY/gkBXySHkFhGNu26nFQF6R/Ddc/D9c0i9I4TQPUL3HKB7Dvwkw5YR0HePQL0jVBqbLSP8+xwWA4ZFl85PHYBTgOh6B+idQeqdAT8Q2y4A8W8rtwzQOwPbOwMLnQNs0AFoBAi9A6TOAXzvDHzsHCC43gE6V3YEvR806P2gQe9iukHHohGg902m3sW0d6+CYu9iGnsX09i7mKbexTR1rk2jcb0DdC6m0fbOwPbOwNneATp3HaPvnYHvnUEwvQNA7wCdK7u4wYRFI0DvDHr3KmLvXkXs3auI1PtBi70ftNi7mMbebXLvyZCYOhfT1LtXkXpPhiRregcIvQN0LqbJ+d4BehdT37uY9p4MSb17FQl6PwfQ+0nG3jcZe2dAve8B9S5F1Llnl3o3+in1vge922RrejfKU4TYO0LvVnOK0D0H1/0+uO5lqfeAf4oAvSP0HvJPEZqllUxjfUwMLi/QC7C4ODAX+4na88XewIvFn09+wO/MT9yXH9zZ/SK7Mz+4Lz/tdQ839rOz8px2xiftq/xYs6/nq7IneEc/0y2Z/Vj/Yl9m5pttnFdqRmegMB+cZvOo2DxYzeY1k0fN5FEz+facyJ7NB83mk2Lz0d/cfMjmAa+bnyZQ8jkJ098hlfajavtJN/32FN2e7TvjdNvXTd/dusFyZ/vO2ZZ9H/MvgaeJMSrt37zJinC271r2Q8qbcU2zXFDaj6rte6/bPqm2f/uR7bb2ddOHpNo+6q44UTd90k2fdNOPuulH3Z2GpLvTkFQ3W/7m7xY2to+7sf/kx5qd+YF9+fG37qO6NI93p9jN4WWifKrrNDw2pX1SbT9Y3fZRtX3QTR83qNogV+cRlxuEhecQ0D0E+f4hYvcQlRUl0eRjMaK93PDMVg44aKn4jQ2bKhCpkkAVjBepJDSCtSKVhEZll/WmShZLRN6LyHsR+SAiH9o0fGP15FRU8nHXwZ1DVHa+i+fN7JJt7GwZzxvywGKvs+fzxsEo9h4Ue096vaNi7qiYOynmXumwqPD+Ez2h/Xonvd5/ole4X++o1ntls2sl3vX2xcDobZvA6m2bKrun6/DuvGLvetsm8Hr7BPALxquQN4GPseGdIO/DP/15uQ+/hV8w+ljjHs+HTmBKpfu0b/cUrrmnfbOnsw+ypnS/b/YN91E1++RUuyfF7tFoZo9GNXtr913f5yMnJvet13enH7zMRk6ruMtk932r6sk+ufc3P11ru/PobeUsi924dy4fhOK8L9wHs2/350OMWPf7Zr/l0UcWYd+PyfLooci4R83uUTV7TJrd82MfLe7jvivYlnvS7D451e6jYvdkvGr3qtlbzeWerOY6hxLbWtnzBgJ2mtU4GwpsXzDmY6AXpyS6aZz1I0TsHSLyT++2IfpnYftnYftnwe/VuG0I7B6CH+RvG4IdDYKbRbCY1jjVIP/WDcxf7BZ7NJ7cMO+Fgst7ggRceAfLXO3zN4fFZA9r2dk0113OWbe8+IkJP74/OJMwmBRM0mByyQRGOSmZjHJSMMFRTkomcTC5ZMIfnHNwJjSYXDLhDz08OBMcTC6Z8OdBQH7ZCmiPxyQMJgWTNJhcMEn8BBdkEb7UHIIJv7/ewZnEweSSiR/PTslklJOCSRjlpGQyyknBBNxgUjDBweSSCb8I6+BMYDC5ZMKfy3BwJmEwKZikweSSSdxiyYSKROkgiSZ3lETxEIk6w28T8RoThaMkmg6SqD1G8+LMJusCNSTqjtG8TMaO0rxsslJTRaJHaV78UZoXfmXna0z0KHcUjtJhgGOMR53Bo3QY8Ch3NL2adtT5c6IBLhO1/OjFkZ0TdbTYpODVTBnW8/tBhS/niPk0R4yvcIFRg0plXHRwKt4MKgwVGFQYKnwflyj/CJASHI5KZYhzdCpxUCmp8AtrDk8FB5WSCn8C1OGpjNqWozJaZoYKjbLCURktM0MljpaZozJaZoZKGi0zR2XUthyVUduWVJwZtS1HhQaVkgq/b7hNNp9VntwBqeCgUlJxo6xwVPjZ7PO7NeuSfZHok6zyaqApq7x8xDNWOmPlD2TO2z/GxUna/F6RTT+VBQtNWRTJCEUyfoeRtkwWrdJVa8qSROZrW1euKBDW2NwGmkUJtyEJioSv7XT56xxVqvNf6Ci4XT3GPtC+/MC+qrlg3AYlKJ8hYg3BIgaKHNHeHFnYmyN6NUt7vckuvA2XfZBAr2axdiPReJQ7Gl/NitdGoptsIK4i0YPcUTAHuaNQ6eiaPF60ZmnntYyHXXKZiilWjQJ/GsPhqVRaaO/Pib7CNW8NKpUZpaNTSYNKScWHQYWhUptsgZxoPF5tW1nzFkw+cjCY45WVypq3o1MJgwpDJQ4qJRV+S3sL+dBZC2COR4UGlZJKHGWFoVJZ3XV0KjCoFFTQ2EGFoRIHlZJKZaelo1NJg0pJhd/4//BURllhqPhKvUJ5zRskdzwqcVApqYRRVhgqYAcVhgoOKiWVygzl0amEQYWhMtoghkplLs6f1+h7f7h5W6zMxR2dCg4qJZXKDOXRqYRBhaESB5WCCplR23JURsvMULGjrHBURsvMUHGjZeaojJaZo1JpmQNlKni42WyqrKE8OJVgBxWGCg4qJZXKHpNHp0KDSkkFR1nhqIy12QwVGmuzOSphUGGojLXZDJXXc8Lp9URj7SUp5GYFaBHCh2dZkMmSSEZeJiORrLbWuiVDkSzJbkBtkW9LJroByXiZLIpknieJ5x/9ojv/gBrohwr4IokBs2rRQcqqKFFV9gJpOOTPzG6pYhCpRLGSF6niepU3BiUqa0UqUSwniuVEsWqHuzRUQaQSlHlvKgvSWqokUVUWNDVUaEUqkqhIRINEsaIoryhiWGmOWqogUgnKYTDIkic/F3kKl9sqhgrBFOauUQIoNSDQpPUavs5taGjlthgnlTVOpEKJqlJPt1SiWE4Uy4lieVEsL4oVRPcriGKBKK/KznotVZKo+Oe+qRI9KfxPc6/WMZbfNi3ljQOTKzWCesnyXfircRzff29oaL2Gf+obmvX1rONf3jY0gjjeCzRxvSYI4gRBHP6FQ4K5XCdypYbWa1AQh5+0bGhgvSYK4kRJnFZfgNHw/ajr9zSt73NM3fL1Gn5xTUND6zVu/bPgvRFo1tcHPliBBtdrQBAHBPmAoOyg4P7gynLwffr037efH96+e/zwZVKc/vGfj++/Pnz6+Pzx6//+nv/l3eeHx8eHv978/fnT+w9//PP5w5vHT+9P/3Znnv/zO4VwTwgnL9Mn9OYe4+nTCRlGvKdgpk/2dKkP6d5DOH083YQY7H0MfnI0ufo/",
      "brillig_names": [
        "timeout_game"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": null
      },
      "bytecode": "H4sIAAAAAAAA/9VTvQ6CMBBu+YmCMqiJbia+QREMjCbuvkMDMuqAixuPLjXX9FKbMLQ18Uuaa+Hy/ZSDEgUKNSIWkCQHqAnUAL0Px3WGM7NDnmi6LvlrVhaJIZ9D/x9+6sm/gOT3dP9sBjyXQfHjLFJ3Pq4UzYSvzPKb+cy8mci5+kHOEcdM08aghmehoYci3zvYZ4Y+iQVR/3Q0uM9V1YxJvRD4Y/LtHevHWv8WzqnmX9TIwmdX8bwreMdPvG3Lhq81foEA3dM/z8Ie9lOzgDMuiZqN/nVvro/nrScTECRvfuFT84YGAAA=",
      "debug_symbols": "ndLLCoQgFAbgdznrFh679yoxhJWFIBZmA0P07qMxl2Zoo5uDv/gdN/8GPW/XsRFqmBao6g3k1DEjJmXTtkfQaiGlGJvzNRA3EI/3y8yUi4th2kCFFCPgqnen0vpBSA5VFu+3CJB6i9hbJN4i9RX0+g9CivxtCGLyURhnB0vDWBbG8jBWBLH4ugwE8+zLyvSX7TbemRaslfxVt2FV3al95jHzvyLOeup4v2ruKnlqo5015hGldq1d/QQ=",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "owner",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "timeout_blocks",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "get_games_length",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        },
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JgACBAEnAAABBIBEJgAABAMmAgEEACYCAgQAHxgAAgABgEMkAAAAQC0EAAGAQycCAAIEgEMmAgMEAToNAAIAAyQAAAB5HgIAAQAeAgACADI4AAEAAgADJgIBAQEjAgADAAAAaSQAAACiJgIBAAEuDAABAAIsDAIBJScAgAQEeAANAAAAgASAAyMAgAMAAAChKQEAAQX3ofOvpa3UyjsBAQIlKQEAAQW+Hj//PqT2+jsBAQIlLQAYyhjK",
      "debug_symbols": "5ZTLboMwEEX/xWsv/MJj51eqKuJhIksIEI9KFeLfOyBMKEHJhnTTDXisY9/rGXsGkrmkv119mVctuXwMpKjSuPNVidEwUpI0vij87bqdJmz6aDvzbR2XU9h2cdORC9eWUeLKDIfAGO6Q+8KRi5YjfYQZiwLMRLTCfFr4QCulw9Y4tCsN4gA2UooFNlKZLfxJCagTvJsgwNH8H3o/I++Kr3nXr/LOI1CB1pI9924VNwtsleY77wZO9c7Zb++oYMW7FfD3fonoSMJwG56LEeKVhOAQJITa3M/oqMagWKgxqM1LPKwx3H2AkOo5jOeDNTEYyN2VwKl/ctYRo6+48XFSuKW75n2Zbppt9127Xd+tmyp1Wd+4qQPfm++cNCGogDmFU2CoZKiBOj8=",
      "brillig_names": [
        "get_games_length"
      ]
    },
    {
      "name": "get_game_id_by_index",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "field"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_game_id_by_index"
      ]
    },
    {
      "name": "get_game_by_id",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "id",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "bet_amount",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "token_address",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "is_completed",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "blocktime",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "player2_address",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "player2_move",
                "type": {
                  "kind": "field"
                }
              }
            ],
            "kind": "struct",
            "path": "game_note::GameNote"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_game_by_id"
      ]
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8861757336002045335": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ],
            "length": 99
          },
          "9862881900111276825": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "field"
              }
            ],
            "length": 35
          }
        },
        "parameters": [
          {
            "name": "log_plaintext",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec"
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15733354797221546546": {
            "error_kind": "string",
            "string": "Not enough blocks have passed for timeout"
          },
          "16541607464495309456": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2169137763093847922": {
            "error_kind": "string",
            "string": "Player 2 hasn't played yet"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2701317986746916850": {
            "error_kind": "string",
            "string": "Game already completed"
          },
          "3295174574362609801": {
            "error_kind": "string",
            "string": "Only owner can set timeout blocks"
          },
          "4255801969160781417": {
            "error_kind": "string",
            "string": "Function _add_game can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8032895601730151160": {
            "error_kind": "string",
            "string": "Function _resolve_game can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "7X3bjuQ2su2/9LMfeIsL51c2DgaeGe+BAcMeeDwHOBj434+qqqXMalHJZlBLxVTppd3p1tJaEUFSvAb/++UfP/3tP//868+//u9v//7yl//575dffvv7j3/8/Nuv06///vnDl7/9/vMvv/z8z7/e/+8v7uUPzq/P//tfP/768vPff/z4+x9f/uKD/+HLT7/+4+VvecL/78+//PTlLxz//D8/fBFtRWhsRjRz5GaO3MzhXWiHSDPEt7P4dpbg2yHcDImuHUKtkODbWH5YP+pCdvPDLka/PC7hjSHBGTKaIcBtCHAbItyG1Fz7QmquF4F8O6S9XlBz4x44tUOaG9Ig7U6W5iYuqO8sLOrz10c1puXR6Pnt9Qx9fXbY1yfs6xX5+ugi9vVY9Y1f+ObXlwumxBnkJemCCi9v6BLjZBEjKzEb/YwPEjOSZyK0gsfGflTz6zP09QlbwZNAX0/YCk5Y9eyxry8WzJB8+Aqa+mC3blnIgqyE4kYSM5RnujvzfOtpi3Pf9M6iRvD7Ffv+HMDvZ+j7k/Pg9xP4/djymfqH/JX3g/UHYP0qPEyy9KEo397sX4Crp1Pi+dXTX/P9GLzQTMUYbp8T/fP9gD0FPdRODrMYz0wVO8PUyi1Nd7x7OnDp3SI8v1tfnrh7+sVS4Q+z9CUwDy0Vng2djFieJf8qXNOzCs9PKjwfW/nFLQVX2FWEx5uM6DVVKkWYpM5VyGf3baWg5D/OUukIEaX8pMIpPavwY78UGuLSmsfqFzFHnb+ImeTxF7E2iU0cPo2l8lkslU8TU/k0MdVPE9Pu1QyopXm2lJyPK+n0rNLZPa3X2aWRpXO+SU+PqwbnuVMv7q6zm+ObmflTmLkxmdKk/VET88OBLkw3F3KquJB8Wgr5tLb0bSH3erml4JaNqatP75artJTcEq/SUnTLVVpKbilv1ppeO+tRvpuTCtPUQeHDqIHmrvH7Fc5uW2NcbI3J3x7W9KwOL291uxyOc/hVwo91OLvL4cc6nC6HH+pwuUr4wQ5Pezjc5cXhIVwOf+jwfDn8UIeXt39dDsc5XC+HH+rwfJXwgx1+lfBDHS7uKuEHO1wuhx/qcO8vhx/rcL4cfqjDg7scfqzD6XL4sQ7fYWj/yV0Y4+XCXhfq5cJOF5ZTc+hNj0qQigs1heXpxFp5OtK893yC3Z4tn1PI6euzIfjw+OFPHkiOVyDPEUi9AnmKQMrVtJ4kkHwF8hSBVH8F8hyBvGrkOQKZ3RXIcwQyXYE8RyCv4ccpAqnuGn6cJJBXZ+ccgfRXZ+ckgaQrkOcIZL4CeYpAhmv14ySBvIYf5whkvIYfJwnkNfw4RyDTtfpxkkBew4+TBPIafpwjkOX0rVcgny+Q1/DjHIHka/hxkkDKFchTBFKu4cdJAnkNP84RSL3WI88RyDz06keIt0AmugK5Hcjsh/5GynIFYZAYr0A+CuTQk+ZXIL87kGHob+QVyO8PZLoCeY5ADj1FdwXyuwM59g6BK5DfH8irs3OOQI69Q+AK5PcH8qqR5wgkXcOPkwQyHZ6hDHZ5bKabW2qXxwah+Q6zoKLvnn71S778UvILx8svRb/o5ZeSX+QqL2W/XOWl6Be9ykvZL3L5peSX7C+/FP3Cl18Kfpn+4y7HlB1Dl2PKjtkjp/BzmOrj5zFVP42p4Tx7jp/E4efZG/wcDo/n2cP7JA4/z17b53B4Os+e2Cdx+FXCD3b4eQ6dPofD6Ty5aZ7E4Ve38FiH89UtPNjh10fzYIdfH81jHb51WfvlcJTDz5P54Dkcrtds4cEOv7qFxzo8X93Cgx1+dQsPdbh312zhwQ5Pl8OPdfjVLTzW4f6aLTzY4Ve38FiHh6tbeLDDz5PB+TkcHq9u4cEOT5fDj3X4NR9+rMNp6NnCphRfz+FwOc/J2ydx+NCTV2d0+NBt+AkdrkMP7c/o8KGH9id0+NgrPmd0+PXRPNThYewVnzM6/CrhBzv86hYe6/Dyig8uq5EuD2fPBTk6lJzy5PWHySmfgIPJyaKLnFxNQSVhLpck6a4mxfRV/KG+DM7P+bOCi74iPvEyh5Q43SbtJJTal5jz0r74b5Nt+VBOZPiyjXdW7116558fDnSL8ze3xHURS3xwEZObnLSWQ34sOXkoOZxKcqav1FwTJcT0uDBPZVEWRdOPWHm8wVRxYTE1cM0vvLyY9a7pS7nw9NS+zNVVUqBVDSzno7r8It3Ft0m7hLQ8HPM77a9yNA0lJ4ex5BTnj4R5LpYi3tcK8dRbXApxuOvfHluI8+3hHLRWiJXmbodMHaJvC3F08Tx+Ybl1sGKvX/or9y3lqPC7h18JfEITKJggBDQBgwnKmzv2JEAHOaKDnCKaAG0B9RdTXVoh9W5NIGAC9mgCQhNkMIFENAE6yIoOsjKYIKMtyHTkeJGWsQJpbbompaW/NP0112Y84mymTs3ft12P5NyhZua59WRPNTODLBM7IVfMzLRMHGeisDaz+9voKC9Tao5DXFNkOEX/jG+dQuEUAW9FY1foFdPY+XjF9H8sXbhVn2lWz69M6f9cVinE4SnwVijeCsVbkQ2lMEszhlwwYLgd450BQwZMbseEaMBoOyYafB0NMU3egDH4Ohl8TQZfk8HXbOBhg68FuLrxRkBgAnVogoQmUDBBjmgCwRKw82gCBhN4tAUeXNE4ODRBQhOAKxrHgCZAF9OELqYJbQF1F9Psb2tFsTITsOe2DSYaedE4R17cQunxwyEsE0Eh9C4ac//w9D6kxKsywwwmkIQm6J21CW6JQXAxrAi6e0FVAgUTdC+uVwkYSyDdk5xVgoQmAAdZuqcWqwRoC0L7KFtC+4yGRG/A9E8cVaY8JTk8RcJTwCfRhfBWcPukijR+6V4w6rqHj7X5SPUBT8FwiuDxFHgrIt6KiLciGQp6ap8JVMOMo1L7TKCyN2DavzsqzoDp/e7ocmxG70ZQ0ZeOzbCfAz8Nt989+6qle75xTy0j+SUfqWU5MsUS1lq6Jzz31CIHaiFaTsDQOka5exp1Ty08jhY/kF/8QH4JA/kl0EBa8jhaurfL7qlFx9GS4kBaBvoGdG/t3VPLQG0dD9TW8UBtnbiBtAzU1slA3wAdqK3Tgdq6PExbFzbuPUdpWTaFk8a1lnBoeVlmGdlJQYuMoyX6UcaNkxYeR0sayC9pmHmG4Lrn4PfUouNo4TCQlu565GTRIhUt02uX87Th/vBteBPTvd1yVzEjeaZ/WrVJzJKTyAf2azE0kJg8kmdyOlTMbQ3m/ujUIiaPI2bjap6PEqNHiolhqdoxrqq2796TsauYkTzTnQ3ALCb5tRgZSEw89EMZednaGIXWYnggMWkkz6SRPEOHfiiTW8QkXxBDA4nhkTzDQ3nm0C5EumXdSHenu2cx/dObe4oZyTM6kmfA57WCzwFNgD2vFQL4vFYIjsAE3qEJEpoAXExDiGgCtAXg81oTAbqiJXRFS+iKljKYgNDFlNDFlNEWMLCYrh/e8cxcCBIOlb5fzqJJOrpxUHTzltEfye7sVfF22ia61c7iELuPVFUJEppAwQTdRyeqBAwmCOggB3QxjWgLIrqYxv5iyroQKK8Iuvf7TVXVLwR311osBAomoIAmYDABOzRBQhOggyzoIHf3KmoEirZA+4vpss0nei+VLoh3t0TcdHuzT2/dtP4UnTvLobHk5JHkJBfHkqNDyfFjecfLUHI2Trv4u1tzpDaecX5Zbnh3uU0x7wnM0tt91NOLfcFS/iyWxk8T0/KV9Ge0tDt/wzs5qZLKyNPtDjK+u/nv6y0p0wRpHEtO8ZMzSBKpNlN3vHkoJD621Dy+W2eSk4eSIzKUnPIYY5AbdtpM3fHmockveh6/7Hfz0LSG1F25b9/J6JU6e5L9g6I95VD/oGhfOTKUnO7D/zvL4aHkhLG80z/Tvq+c/k63Lt0WDXedXXKdjXGTnZUuN20sD5zPzk8Sz42EBKezs39J5U5OcO/kvBEImIA9moDQBBlMIBFNgA6yooOs6CArOsgZHeQMDnL/HQZVAnCQuXtPbJUAbkF3MY1hniKNMVVu191zt1j/7QgxLEeuYvSrZVfuTmpVI4gRTSBggu7dtlUCQhOgg0zoIHfvtq0RMNoCRhdTQRdTQRdTQRdTRQdZ0UHO6CBndJAzOMjiIppg1yDnsCLo33tbI2AwQf/e2xpBQhMomCCigxzRQU7oICd0kBM6yIQOMqGDzOggMzrIjA6yRDQB2oL+I0OVW0UmCoFTZI+nYDSFOrgVrdeivGKCb8fE/vtwHt/HETRFPIXCKQhvBeGtYLwVYiiFQu0YdQZMMmC0HdN+yXrQ9kvWQ+u1EW8Ybsd4XKrpt/cT+P0Z+35g2t639wv2/TGA3w/WD0yD+/b+YvkMabn68+WMwgILWfqW2rdz4ryqKafT+jA1Y/kGXNO7h0K19yv2/QKu6cLY9yu4pitYfwZ/Scv7bT+qNpYnkj9Gzcs5+KHUQGt6dD6C3y/Y9wcPfj9h3x8d+P1o/Rn7/vK0wEfVxvIMwkepoaF8Q9h0SNGxRxMwmEAcmiChCTKYQCOaAF1Mwdk/JwKwBR6c/XMiAFc0D87+OREkNIGCCUJAE6CLaURb0L/uzn5JqsWxkpuwclgp9meO31kOjSUnDyWnfx/lvnJ0KDk8lnf6d3TuKkf6k56gTnc12fn4dNdkJ38OO/WTxFPHPX25q5392Qru5bzPtPBGkLEEwUU0gYAJvEcTEJoAHeSQ0ARoCyK6mEZ0MU3oYprQxTShg0zoIBM6yP1nvEXn7F5R79J1FR/eMf3+JL17iHubFY4aKqnhdjxQGUP/KSmJ87NTANZh7V6krhF035laJUhoAgUTdE+mVgnAQd7hhoIaAYEJPNoCn9AE4GIaQ0AToItpRAc5ooMc0UFO6CAndJAJHWTaM8jKYU2QwQT9M5M1AgET7NovKhIQmgAdZEUHWdFBzuggZ3SQMzjIO1wlUCMABzl5jyYABzkFhyaAW9BdTDPPw9iY9bir9WLq7nElF+ZpieRSJZcf6bKYTtlVMpQr8/xmvU8NvkjP3dKXhMNTPa3lMq4syPVnrN9Zjg4lp/to/M5yeCg53ZODO8sZyzvdOyJ3lpNGXcFss7Oygplk2JXafe3UTxLPjWnS89kpezYXmr/t7pELaAIGE3iHJkhoAgUTBHSQAzrIER3kiA5yRAc5oYOc0EEmdJCJwASMtqD7nHUtxU7sT39ep5CIp1A4heKtaNx494JhF9sxoT851OP8Ny+bEPEUBKdIeCsS3grCW0HaXgo5GDDSjmlPxRS5PRVT5PZUTBPGUOPV4OtsaCUy9mi7uAB+P2Pfj00HNb0/gd+PPdren/m29n5s6oiNvLcfdPxcylt5P0pNGso3CVzTyYPfT+D3g2s6R/D7wTVdwPoF/CUtH8D6qNpYTh71UWryUL7J2JquzoHfn8Dvx9Z09QH8fmxN1wDWH7BfUt2YFpC4LOTI3VGI15vgcbVRN2YQPkhNGso33XtCKtkndshWXSGgiCYAZwBRdEYoRWeEUnRGKEVnhFJ0RihVtAWKrmgZXdHQGaEyOiNU7j7EVCUAF9OMzgjVn528RhCAxRS71TUHPVT6jsdYcwQ3DjmCm7ecwB/J3D29lEjnGKRpjbGiprJJMPdvMN1VTv8i+75y0lhydCg53TNpO8sZyzvdt1ftLGfY/FRtdlZ2VeY8bH6qne38FPFMGxnsT2hn3rG5YP/t4a/k+re61ggUTBACmoDBBNGhCdBBjuhimtAWJHQxJXQxJXQxZXQxZXSQGR1kQQe5O2HTNCfhFwJKK4Lua4WqBBlM0J26knzgr8+ST7wmUCyB7z7WXyUQMEH3sf4qAYMJuo/1k89xJgjOrwi656woLp1dikIrgu7bZicCXQg0rgkUTEBoC2hfC2RFwBFNgLZAdrBAFoJcyZ7opyXh+cXT0ufycMiznG57J5/NclJcF4nuZHkVgtC9DFQj6B7RVVqu0L2IQrwcgiFZd3JC91JHjaD7wAWHPMeAX7ZLPO6w7LeWkkL3QY4H0t8IUjdBnJ0/cdGaIIMJuhvdKoGACbrzm1UJCE2ADrKig9y9ZaJGkNEWZHAxjc6jCQhNAC6m0Uc0ATrIAR3kgA5yQAc5ooMc9wxypFUvvz/va5WAwQQ79IsqBAlNoGACRgeZ0UEWdJAFHWRBB1nRQVZ0kDM6yBkd5AwOcn/e1yoB2oLubgupLtNK2R13KUdK3evN0xLPMnGruhqBpyBggujRBIQmyGCC/snzGgE6yIQOcvd6c42A0RYwupgyupgKupgKupgqOsiKDrKig5zRQc7gIJPzaII9g5x5tamgP+VklSChCRRMsGu/qEjAYIKIDnJEBzmig5zQQU7oIBM6yIQOMqGDzOggMzrI4tEEaAu6L05kR/Oz7MQfN0Cm/h5XXjYgTFa4lW+6Z4iqBAlNoFgC7k6sVyVgMIF3aIKEJshggoC2IKCLaUQX04gupgldTBM6yAkdZEIHmdBBZnSQGR1k3jPInlZb6rh/JqpGIGCC/pmoGgGhCTKYIKODnMFBFufRBIQmAAdZfEQToIMc0EEO6CAHdJD7Z6JqBGgLurstnJYLGqc+UGWAXEmkkKT7rMrOcmQoOd1LeTvLoaHk9G9r2lfOYN7JQ8nZ2Hg+QOaJNjsrmSdkY//76ezMnyOe6obNgLOznbxnc5FXa83qPZqA0AQZTBAimkDABBEd5IgOckQHOaGDnNBBJnSQCR1kQge5e2KySoC2AH7z4EShcIrubf3fQSFwigy3IrffhZiyD+0Y+OWGE0XCU2Q4RcJbkfBWEN4KNpTCxo00r5j2uxAnDBkwuR3TfhfihNF2TDb4OjffO0nOeQOG2zHeGTDJgNF2TAgGjMHX0cATDb5O2PssyIGvXZkIMpgAfO3KRCBggu4tkFUCBhMIupgKgQkUbYGiK5qiK1pGVzTwtSvkwdeuTATgYuq9QxPALegeg9Mtp9Q3WUubV1jId29r3FmODiWne8vkznJ4KDnJjyVnLO/0J0nZV04adkmqyc7HS1KTnflz2MmfJJ4bWb7PZ6fs2VwEXnU8NKAJGEyQHZogoQkUSxBcQBOAi2nwaAs8uJiG4NAECU2ALqYRHeSIDnJCB7l7YpKn0edMIHeLdwtBBhP0b4utEPTn2FNaCFTSmkDABIK2oP9kc42ge9dFXuZLZFpaefww6fIwZffu3tZCt4+XzQrKd3lM3tYAKXR3J8SlsEgXWfkm9/pGvJsX4MXHb1OVUnQOTZDQBAom6O5OVAkYTBDQQQ7oYhrRFkR0MY39xZTSQrBuRmP3/r4qAdoC6rdAZCF4f5fjG4GCCRhtAe8agwKBRDBB97HdKkF3azqtIcwEFFcbCmLutoDdfFRO+H2ndP3wjqleJun9vkl5ke6+PeVHqXt5sEpAaIIMJug+r1slEDBBQAc5oIPc352oEcAtQBfThC6mCV1MCV1MCR1kQgeZ0UFmdJAFHWRBB1n2DLK41RxX6t42VSVQMEH3OYQqAWMJyDk0QUITgINMPqAJ0EEO6CAHdJADOsgRHeSIDnJCBzkRmIDQFnQfvhF187OivnYHbWXbEvX3onaV09/n2leODCWnvz+3rxweSo6O5Z3ulbud5Qy7b6/Nzso+r610x+ez83PEkzc2RJ3Ozv4e/r2cuBpKsxcwQfBoAkITZDBBjGgCdJATOsgJHeSEDjKhg0zoIDM6yIwOcveB0SoB3IL+PBCP04sQ9x8ZrVMonCJHPAXcitZMyK8YQwID6Z4CquX+IEkOT0FwCsJbQXgrGG8FG0qhBAOmPY2GqDdgqB2TnQGTDJh2X2t7EqkJ0+5rbU88NWHaU5ZocAZMMmAMvo4GX0cDTzL4OoGTdCg5NAGhCcApLpQjmkDBBBLQBOhiqh5NgLYgoytaRle0DK5orZkTDQTgXDLZezQBuJjmgLagfz4wp2W3dObK2ajaCkt/Fs2d5aSx5OhQcrrv/t1Zjgwlh8byTvedePvK2RhUj7Ak1WRnZUkqb8zSns5O+STxlGFvQdnXTo17Nhfrs3hZFUyQA5qAoQTsnEMTJDSBggl8RBOgLQgBTYAuphFdTCO6mEZ0kBM6yAkd5O6JSb0dHKW7M7Xh6+ubFwzYsTNgDDxi4JFkwOR2jBp41MCTowHTPCnP3gUDRtox3sDTvtDCvn2hZcKQAdMeUx+TAWOIaYoGjCGmZIgpGWLK3oAxxNTQ7vjGdqd9l8VEkeEUGvEUCqeAb6rh4NqrcPDt1TF0335X2wIxURCcAr6pZqLAW0F4KwhvBRtKIbd/FEL7LpkJ0/5RaE1i94YhA6b9Qx8Mnbdg6LxFQ+ctGjpv0XsDhgyYdl/HEA0Yg6+jgScafJ2wC5ATAYEJwFtqJoKEJlAwAXhLzUQgYAJBF1PwlhqOirZA0RUtoytaRle0DK5oyQU0AbiYJvCWmokAbUF3Eg11SwpFde8vGG5eCOf+VGQ7y8lDyek+7LezHBlKTveyws5yxvJOd3q2neX07wTxzvPdqPqOI/ftHWiz9PHeAU477O15Fks/TUw30vae0dJiJ1B8nhP1y/SGP+/ms4ptgSx9kOlHrDxuM9U7ffxwCDy/OIS7ywXKDpe07EuSqVdyL/nVL4alxmSYrUrZwJPbeaj9TBe35qh7xRjm28kbeNqv1Z4w7TNCFL0B0z6jSsnAk8iAga9n9ecr+w4K+HpWf16x76DAW2HYZUHaXh0ZPRJn8DXDEwGhCTKYIEQ0AXjCiGNAE6CLKXoBgRPaAvQCAhO6ohG6oqEXEBi9gMDoBQRGLyAwegGBuxcQ9DaG0hDWBN0LCFWChCZQLIF0LyBUCRhM4B2aAFxMJaAtCAlN0N6fFcOGAzHsFhXDblEx7BYVw25RIQMPG3i4fbgs4g2Y9uGyGDY6GdIBTZj2cZrgd1wKPI0Za/8icZ1C4BQeb4Vhr5XG9uqITsozESQ0AXgAgE7KMxGABwDopDyMTsrDquhiit5BhE7KMxGgKxo4KQ+jk/IwOikPo5PyTATgYpqDQxPALeje5ROX3Q4aI68Iuo/sVgkUTNC/t6ZGwGCCHY7sVgjQQSZ0MWW0BYwupobzLbk9C+w0sWXgUQNP9gZM83B5ahO9AWPg8c6AIQMmt2PaM7pOGANP+9TRhEGPUKU/KcN3UDCcgjyeAm9F+9E+ce1N34Qx8KiBRw082cCT23kMORbEkGNBDDkWJoyBJxh4goGnfePThGn/ZPhk4EkGHjLwtOdpmTDtnwzf2DF7w2g7RqIBYyg7hjbEqyGm2RDT3B7T4JwBkwyY9rJjSHAwYdrLTjC0O8HQ7gRDuxMM7U5reoQ3jKHsJENMyVB2yBBTNpQdQ9/FkJZADGkJpoVeQ9lRQ0yzoex0T8bKnFFMbhcHUvj68ox7eeyeI3308v5LDB+9nIEv77+88NHLkcr7Uxg+eHmKyJcr8OWEVE5I5QxsW6IgS4sgy7kia6gilWek8u67Oh68PDmHfPkOm92W6eXbqbbpO1F4lnRWQhrfPfumJY+jpTsv8J5a5EAtHOaFP4601hLCQFoG8kukcbQkd6QWf9PCBS00jhYayC+k42jhOJCWgfwiA/lFjmzrbost7GStRcNAWgbyS6ZhtJBzA2nhcbQc26+raNFxtOxxZGQ3LXkcLXEgv8SByksaqB5xsbzobQujTnPfCyyQL8lJS59ap05I5elIcyKadHc6KpS0h+jmZ6eFmPT44X12aBYeluU817QqePOFd6U7o8JUBWfJKvru6VeHl5PEXw7HOfwq4cc6vNytvBwOc3h579LlcJzDrxJ+qMPZXSX8YIfzyA4PeVEfHZ3C4eWDWZfDcQ6ny+HHOnzofvgJHV4+oX85HOfwobuFJ3R4vD6aBzv8+mge6/DydoTL4TiHXyX8WIfT0PPhJ3S4Dv3RbJpLafFijCl+fTgmf3tY05Gh1EXEFMpUCSX5NK/dkZd31x68RXLoSZorkt8fyXzVybNE8jyrjZ87kuLSFcmTRPKqkyeJpL/q5FkiqacZ9n3ySJ5omeGzR/I86xefPJInWhj57JE8z3z0Z4/kefY/fPJIpqvHc5ZIXj2ek0SSht4hfEWyIZJXnTxJJPk8m8g/dyS1nP/tceodLed1q4FSCfQ4wYOWu9YVULIwlT8zNZAYQGxhYgtT+fK6x+eGtXx7XQVUviSpBrIwZQtTNjHldtDGRUK8tF48Vbw1SA0gb2HyFqZyG1EBlSeqaiAygMqJbynMILr/FH3FlPemVTDajiknEapgDDxi4BEDTznJTQXD7ZjytpkKhlox6soJYSqYctnJaS6kPqwx2o4pV/AKxsATDDzBwFO+I7KC4XZM8gYMtWPIGTCGskO5HVP+dgVZ0osEifFblN+4BY956XCy+jVKLShv4trIhVxDsQW1kb14Gv0sffVMaxSZUNmC2kg3U0OJBbVxrUUNZfIGmzzPNi6T58XkeTF5Xk2eV5M31OSNbPLGxp3Pj1Fh45qd7OfBp8+hgBILypu4vImrHK9ppmUe4Yn4Wxv10g9eU/jJYzOHv7+hvvx4cssMRbrr53gqTSRMg9154PMy3Lt/9av+jcwZe+X7neYcPJqAegkeDsc1li+t25MAbcHGjqAdCRRMENEWRLQF5fv1mggejacnuIAJCG0BoS1gAhOIQxMkNEG5HjhZCGQN0tgOShsfhgqIDSBvYdrIjvEYVE48WgFtXCjp3HLI0N11PMrrBSktHY7pr/lxD2Jq7cKtvOi3fYLE5Z6rW77DflJ0qKAND6WlI+S45iFPkpZhY6z0sXLyc68pT+5YCSpXw3tB3r0X9AbLJthGWugKjMrt9csNd3OHMMRU65o6WZa4ph+x8vjUiZ6fDinUuqbJzRGRdFfCvzqZNrKn6zLOyHerj/rV6I2rxCogMYDUwqQWpmxh2rgG+iGINxJtV0BkAZWrwvJxCnctzAvoyIVov8zRhbCepOONCaankE7PK/15C8zGfN9TSNenlU7P6/XyQOgppG/0HZ9C+vM2jvy8jaM8bzWV562mG53Xp5DOTys9P2/PMT9v45iftnEU97SNo7in7TmKf9rGUfzTNo4SnrbnKOFpG0cJz9s4btxm9RTSn7dxTM/bOKan7a+LDNzCTKsIi/S02iEjeeA+zOONlZIHrqaPpasbuJrWpA/ch6lI9wMP8GrSB/6a1qQ/bzUNT9s4anher8fnbRxp4Gq6nW7vTfrAQ42KdH5er8vAZb0mfeD+ekX6yPPrNenP6/U88BTSdnaDN+kDd3ofS89u4E5vTfrA7XpN+sDdr4r0kefXa9Kft5qG562mI8+vV6SPvFmwJn3g/npFupSraePJudtG6ewrG8b1toGdbnby207mvHEU9MPk0FByNnZFfJickbyTN1JdfJycwbyTh5KzkR3hw+ToUHJCGEuODCUnjvSRyBspXD5MThqrGUxjNYNprGZwY5L6w+SM1QzyWB+JvEu7s5llovAw8aKdmO8ffhHkvTtaEOu85vJyX9xaEB0uaDmrWhQUDveQLK8WeV/c3gTRYILiaB6KOpigFEcTNJqHaDQPkRzeDu2VxuhVP8dx9L8K2lilqxqysURWxWUjX7bxhXKKje/AsQ3njXzeyLfxHazjyIjLNtzGTuU6biOF5DxPyu4u20ugN1A5jXYNZGEiC9NGOt7HoI18vBWQhUksTOWNChXQRk7eCogNoI2svBWQgSlu5OWtgJIFZCiw0VuYvIUpRAvIUIxi9BYQWUAWR1hao2hpjSJZXE4Wl7PF5WxxuVjqk1hcLhaXq4VJLUzZEtxs+AAkFy0gC5MPFpChwKbgLSDDByBZWqNkaY2SpTVKltYoJUtwyRJcsricnQVkcQRbXG5pjZJYXG7pUCVLhypli8uzpZRng8vJ0qEi7ywgQ2tEIVhAhhJB0eKIaGFKFpuSxXvkLSBDKSe22GRpI8jSRpBaCqylupOlulO22GSp7mzpsbClx8LewuQtTJbxE1vaCI4WJksbsZEGrgayMFmGQmyZmGHLxAxbJmbYMjHDlokZtvQjWC1M2cKUDUzivAVk6LGIpR8hlokZsUzMiKVhEUvDIjFYQJbgJktwk+FLKGQJLlmKEVmCaxnViKU1EktrJJbWSCytkVi6OWKZJhbLqEYt08RqGdWoZZpYLd0ctXRz1DIUUss0sVomZjQaipEmS3CTpRhZponVsmillr6RWsZPGxfGPgbl8qdGU5j3WU3+vR0lf7l8ePVwdDSvwkcnt1X48rp6nm9g07tcNT7Hr3JkBzmRFjm0WhnNKeApFE5R/jLuSlGeHdyXguEUgg+34K1QfCwUXaK8c7pDxfBu3vkQfaxsLJo+rcspsuBoLSiH0QTJWIK8G8xD3o3mIT+ahzwPJii40QTRaILyHoLSIoj4saCppVmuKZr+nvJaUnkF5GMljeel8szsx0rS4STReF7ao+sZbpJCqO1xdlGXy6ddcrKWJHs0k0o3SaEmKS1n4b2jWGiXhMaTlIeTpGk8STqcpBzHkzScl4IfrhEIfrhGIITxvBTG81Icz0txQC8N90HZOIjxsZLGayopjCdJkJLeOMp7yHfmYDyH7tAfCHnu5sdY74FPa8Nz+KZRgStI0uEk7TFDubckGU1SdMN5KW5cHU5LE6J8d1B3kvQVxibYxvXhVVg2wTZ20C+3fJPenP31svIJtbGLrYYqlrZJ1lcURy6gyt+GKsrEVT6fU0OVR/tVlIlLTVxbZ3TmasJOSii1oLZO6VRQFq7NczoVlIlr66ROBVVsBHjJcsgSCqjyWZ0qysQVTVzldqOGKveGqyi1oMo7L3a7nb7wsOPlYcfrLmUqb+v4SEXih1PEoynS4Xykw/koD+ejjQSeH6koD6Zo44jYhyrS0RRtJPP8SEWjfUU2zvJ9qKLRWkiKo7WQFEdrIWkjvedHKhquhUzDfUVouBaShmshhxuLbBxnhSrKS147l9eTyHz8t9/L/GrxdxNWiyK/R9TiLa1oSpVUde9eHW4TObwoktEUheF8tMu3v00RLWtJ05LOWtEu3/59FQ3no12+/W2KsltefZde96aIRlNEw/mIxvNRPlpRDMurYyy0R5yGUzScj2Q4H4l+pKJUaCE1Dqfo8N5IZF4UCa0V5TCcotF8JG40H4k7vDeSlitEffIFRd4Pp2g4H4XhfBQO742ktBwESBTWiqIbTtFwPkrD+UjiYHMjG0lDkIpCmH0kIa7nRjYykkAVOX2s6HAf+dv1OyGmSqF7+c7NQqYfBQNyHGwCTPJoU3LqRvORej+cIh5N0fELhFVFeTRFMY2m6PjluKoiGk0RDecjGq4c0WB1zW8cPH05RTgrcvcXVfNX2MYMTBW2cXFPXHqhnvwatnVPUA1mYgsbV/rWYBvX9FVh5ULq+bYTX7UAyyZY2rpydumQJVcQmdgEI2eDJRus3EWjpfvu6S59zwLbuIWrCrOxbWzqrME2dl5WYWKClXM112HZAosb9a0G26hvVZiRbcM2Wdby6G60usBCssFsbFFMsI1GoQpjE2yjUajCbJ7cqN3Rh9uahy/A1AQr52Wrw9gEKx+AqcOSDWZzSbYFIJvYkgs2mCkAyTsbbCMA6bbGxK4AyybYxlRwDRaDDSYm2Mbtq1WYmmBkY9u8b/RhvySxt8HIBssW2MZ2c4m3ueS4BpX3F+U0F/9MtAaVFwJqoGQBqQG08TGsjGw27i6pwsq3l9RhbIKxjY1tbGJjExub2tjUFrdsY8sm27icH7wOSzaYmmA+2GDS3vBwecE1LxMjOZRAhtaKy9veK0zlz1IFVD7cXQOxAcSGFpjLn6MKSCxMYmi2N7YE1UAWpmxhKk9FZZpLeZb12GVje0oNZGEqD4oroHK6qhrIwhQtTNUuQxGU24MrKVlAFqZyD7QCKp+4qIEMVUPE0EaIOgvI0JZvXOhRAxmYNi70qIGSBWSIk3pDidCNQRPRMmgiuRs0xTTjxIbbOChUx7ENJ86IIyMu23BqjMPG/E0Vl41xyLY4ZOdtuI05U771PzncdqaQfIVtDNw4LRvs+G4uYIFtDNxqsI0d8DWRG/OKVZiYYGpj28jFUINtDKWqMEu4g3PJBrOxeRubt7GV73Krw8QEi5YaMMHYBNuYlqnCsgm2sdhQg5UHVnWYzSViYxObbWLz5MbXqgoTEyw3l8k/p1//98fff/7xb7/89O8J8/KP//n173/8/NuvX3/+8f/+Nf/L337/+Zdffv7nX//1+29//+kf//n9p7/+8tvfX/7ti/v6x/+Eacb/hxApTILi628v0+8g0+8Xx0+L2/RDmGZ0pt8vHYfpr9PzTPRiwMsLJoX8wzQI9q/N3Mv/0OkN0x950jrp/f8=",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "resolve_game",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "11091894166229312484": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "1705275289401561847": {
            "error_kind": "string",
            "string": "Mismatch note header storage slot."
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6869395374906889440": {
            "error_kind": "string",
            "string": "Mismatch note header contract address."
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_note_internal",
        "decompose_hint",
        "get_public_keys_and_partial_address",
        "lte_hint",
        "get_key_validation_request",
        "notify_nullified_note_oracle_wrapper",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "AAAAAAAQAAAAAAAAAAAAFAAAAAAAAAAQAAAAAAADKLEBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAF\nAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAABNoVMTwRSBB\nbmK2898m428ts6wCdi8GXwYPpuHY4GaFEM/Jk4himuRoHm7O6qJsZ+pYIZ+/jxaq4/45ID5yPBAY\nEbQPsXndNVa87rP3CjKkbdfxBKQzLF6UjKFPRVpWwhQC2fC7AzKkxHOPQ3Ddsn5XXMFJv55459T0\nL5KSD9OaBD8W3hYPHwYT2ietN8KxPTKW7JRMNBVBNqEStnqoLXoamLi70ecXHutg1fVS+lTsKrci\n0Aph/yWsBj6z7OHxsCNrgmg7pyorXBXAJrfiexfMkeVgA4HHj/e/iKkdZcJaGqTU4wK1dnl86nhx\ns/vjbfTXmYulzL8KwRsgqdwxXi4ErGSpA9uX50OYM6RWb3xRTc0p5vijzYSW2y0IsY880io3LmnC\n7JRmJUGsvvlDvsmi4coujBQ4W4QRW/RkI+/zCcnjeVVuq+UP5bU6iFUtOQsAcRnL51O+cXsnElMl\ngtMMHK7sW8p8ZI9Zy20SrCdIC8QAgbm324ZA5HpVq3bFEwRWu3AbWwtGO7zwxP5xkFUjk9CVM+Gy\nAEvYTp+KU6iPA4D05rswR3a/1Psi4gmHdBVkgemj+PCR0w2xADptqrQpjDMR/JFw+S3pQLBCqrmQ\n1TxqOyYznNprc9+SCDFBWQewX0CKYShHJZAWuSBK5L83U36xlrBcHZj6UQFqm6y7L4tcIOQBOwM/\nUpR2HTzYNKDz5OPkvBIpV5siBXX1Nq4K+WRkwqiGMiqMUqLlQsbl526gZxB5STfwOg0laH0buSxL\nDgiPpr7CWDK0hle+yF0/MvYY0Jdr28E6xUROUzqoIpVYGQLy+QZtcOcSXraZsVoR7IT6zUMXc2rY\nPPytfwYbIz9wNeJ0FbTCzxJYhHW5JNaO+GkOhAoYnFH3h+qUJyv+7k7T+AI5GqfSh5lFAcoyrqrZ\necBpo9L6VT9SUZx5J6kcPGuE1vjWkn2h79DfTKo0/HZVWjRSR8Qx5ogKwBgHm/FosGyqZ3sObTHZ\nWDlCc+ixvpF0pzP5gHiWLEkLoAlCyEeGw3XjySQQnHxB813qJ9xjzbzZ0ra8WfibE0C3B8iFGxEY\n6HkYvyg1NXedNEehNEXqSmNec6LiSqir6bQVvnJVgKd6L/pN7jFcBvLkwGS5EkDIPCh5+t0Hvb8t\n0h1r4fbAHyGFHphiT1TciNmPbKdMPAvujFQ5aeetZ11rAU9zX6FVxXbfhiFFC1Wa9qyWb/+a5YY+\nMb6yMyBrP1wCnvNRYNhVbrk7kJhyV9eIGS6Klk1vWOsewBUhjhhbEyUECmyH7qmTJLDee3aDu4RW\nOhJG30WLm94gTH3OYbPjDaqEIchxLWhH6BulCBjDNh4gDgP+OLbEySE7JjoC8SwnkiEnQGjYpYst\ncuaQcadqgvz0qVVBZtB6pVU/wKiRnR9j2tCXzJry1uFAt+qloDX1wb9PN2/A5/UX6l+g0HQ+JqRr\nv/8kiH3Qd1LoIXYSDYrBJwrxNgbuELpvoghSbDoRNjLPfSID5CX7btc0oVq1Q0qJnqwkRTbBgv8q\nLjlxlxogd13zvKib0qdNxXEXUHYI3fBVSlLzn00QGAiW6OZNLnMsdEUlVFxVcGhnzOZKxovMLz7j\nchxLvfL0D8gt+88XGwAcY/b0vsH1yOlRnAQUzjWnDolGWoY1JxbOWNt4cRj3LEUauaCQViRFAw4t\nx4kQ8e+Exmj/ZifLrEi+ykzRCXN/g3+iB/VgknO1cfkDupaY2zaX8JD/zNrfS1eWt+Yu7zyw0ptg\n9e++kA7pI9OHfc7xjoP5hXxSKHjW0q2KKQ6aQJjCD6HkS9INxxaP4cY+BmeO22N3lRXGxsVtPeUO\nIGiJuE0Skfh+i+hKteo/of5Kq2KkCGwylnRviSO1goEK3InEjXW1cWNvW760qAb29FliAjAbauTr\nDrvq3SAzQAZvKBNXSPEZYxw/4H+p1wADTj4nRU75krS/hLl7qnRxLiV4NVHfUMAE7HzR9N2LO2Sm\nbyrEl5tl5WVoxaMbFO0Y92zwzuzLR5jedBrom2ToJY+ER3wbYlZaVZunuziDLgRwag4jrDKjVmkH\n+4cjYhWDsXb1meGS1xGTVANEGej5KQRrKZKTywnFkzcutrPm0bmZInk0L86aiDhJaT/NoiotONbU\nuh5HY6dOzbEcofNGloDCcOVRUVNEWS9ZGI+nZRLbOeiSgmsyYQ7gglHgBfzpF8DV3KAZR3xS9gdT\nMrYSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAilNC7sdV5Sf2QArEU1W77+7NWrKyPucXsOlj57TZFgKBRXSLWXw8L2FnW/dw5I3\niD21TWWsnjihshU8eYbWQMUPy7+dPPQCuqPu2l8Knkm1werJWyZMMC3IVObyLXMw3yg+39qJyUgF\nl/CzRC6XUt751Y/Ckgg2GUJh97Fj/vuvHViqYcZK1SIEPXnEgCIZ5Vuhl1Gt/mw2Mk0/tsLaCYkt\nfBipPD2uWICfqu7GqGp49LO8YfGdbnBpNZu/R+f5Bw=="
    },
    {
      "name": "_resolve_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2701317986746916850": {
            "error_kind": "string",
            "string": "Game already completed"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8032895601730151160": {
            "error_kind": "string",
            "string": "Function _resolve_game can only be called internally"
          }
        },
        "parameters": [
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "player1_move",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "player1_address",
            "type": {
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "_resolve_game"
      ]
    },
    {
      "name": "start_game",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "error_types": {
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2429784973622283587": {
            "error_kind": "string",
            "string": "Can only emit a note log for an existing note."
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3151558035338938026": {
            "error_kind": "fmtstring",
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ],
            "length": 75
          },
          "3478708872465429459": {
            "error_kind": "string",
            "string": "Invalid move!"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8193989641828211937": {
            "error_kind": "string",
            "string": "ciphertext length mismatch"
          }
        },
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "player1_move",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "bet_amount",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "token_addr",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log"
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData"
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "databus"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "random",
        "notify_created_nullifier_oracle_wrapper",
        "decompose_hint",
        "notify_created_note_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "compute_payload_unconstrained",
        "store_in_execution_cache_oracle_wrapper",
        "enqueue_public_function_call_internal",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "play_game",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        },
        "parameters": [
          {
            "name": "game_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "player2_move",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "bet_match",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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AAABAgEsDgIBLA0EAgAoAgICLA4CBCYCAgQBJgIHAQEmAggEACwMCAUiAAAKugw4BQMIIwIACAAACt0iAAAKzCwNBgIsDQEDLAwCASwMAwIlIwIACAAACuokAAAQhwAoBAIJLA0JCQw4BQkKIwIACgAACwUkAAAOZCYCCgQDADgECgkAOAkFCiwNCggsDQYJLA0BCgAoCQILLQQACoADJwCABAQAASQAAAtqLQiABQAMLQiABgANLA4IDSwNDAgAKAgCCCwOCAwsDgsGLA4MAQA4BQIILAwIBSIAAAq6LQGAA4AHAQCAAwACgAstAYALgAgBAIALAAKACy0BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANIwCADAAAC7kiAAAMKSMAgA0AAAvGIgAAC98tAIADgAUBAIAFAAKADi0CgAuADiIAAAwkJwCADwQAAwEAgAmAD4AOLQAAAYAFAQAAAYAOAAEnAYAFBAABAQCABQACgA4tAoALgA4BAIAOAAKADi0CgAmADiIAAAwkIgAADH0nAIAPBAACBQCAC4APgA4nAIAQBAADAQCADoAQgA8tAAABgAUBAAABgA8AAScBgAUEAAEBAIAFAAKADy0CgAuADwEAgA8AAoAPLQKADoAPIgAADH0nAIANBAADAQCABYANgAwLAIADgAWADSMAgA0AAAzhAQCACoAIgA8tAIAKgBAtAIAMgBELAIAQgA+AEiMAgBIAAAzhLQGAEIAOLQKADoARAQCAEAACgBABAIARAAKAESIAAAywAQCADIAIgAYlLQGAA4AHAQCAAwACgAstAYALgAgBAIALAAKACy0BgAuACQEAgAsAAoAKAQCACIAEgAsPAIALgAmADAsAgAcAAoANIwCADAAADTkiAAANqSMAgA0AAA1GIgAADV8tAIADgAUBAIAFAAKADi0CgAuADiIAAA2kJwCADwQAAwEAgAmAD4AOLQAAAYAFAQAAAYAOAAEnAYAFBAABAQCABQACgA4tAoALgA4BAIAOAAKADi0CgAmADiIAAA2kIgAADf0nAIAPBAACBQCAC4APgA4nAIAQBAADAQCADoAQgA8tAAABgAUBAAABgA8AAScBgAUEAAEBAIAFAAKADy0CgAuADwEAgA8AAoAPLQKADoAPIgAADf0nAIANBAADAQCABYANgAwBAIAMgASADQMAgAgAAoAOAQCADYAOgA8BAIAKgA6AEA0AgBCACoAOIwCADgAADl0tAYAQgBEtAoARgA8DAIAQAAKAEAMAgA8AAoAPIgAADiwtAIAMgAYlKQEAAQXonQn+oREtDjsBAQIlLQGAA4AGCwCABgACgAcjAIAHAAAOkSIAAA6cLQCAA4AFIgAADwMtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAIAMAAAO7y0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAAOvicBgAUEAAEDAIAGAAKABiIAAA8DJSQAAAY6JgIGBAAmAgcEASYCCAQDLAwGBSIAAA8hDDgFCAYjAgAGAAAPjiIAAA8zLA0BBSwNAgYsDQMHLA0ECCYCCQQELAgBCiYCCwQFABABCwEmAwoEAQAoBgILJgIMBAQAKAoCDT4PAAsADSwNCgYAKAYCBiwOBgosDgUBLA4KAiwOBwMsDggEJSwNAwYMOAUGCQA4BQcGIwIACQAAD6kiAAAQWiwNAQksDQIKLA0DCywNBAwmAg4EBAw4BQ4PIwIADwAAD9AkAAAOZAAoCgIOADgOBQ8sDQ8NJgIPBAMMOAUPECMCABAAAA/1JAAADmQAKAkCDwA4DwUQLA0QDgA4DQ4PJgIOBAQMOAUOECMCABAAABAfJAAADmQtBAAKgAMnAIAEBAAFJAAADnYtCIAFAA0AKA0CDgA4DgUQLA4PECwOCQEsDg0CLA4LAywODAQiAAAQWiwMBgUiAAAPISkBAAEFAtxuJ4B2Ep07AQECJSkBAAEFRafKcRlB5BU7AQECJSkBAAEFxWvEWg4QAAI7AQECJS0AGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": [
        "play_game"
      ]
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000003"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": true
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000007"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "RockPaperScissors"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "games_length",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "plays",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "games",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "game_ids",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "owner",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "timeout_blocks",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player2_move",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "bet_match",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::play_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::play_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::get_game_id_by_index_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::get_game_id_by_index_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::timeout_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::timeout_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "game_note",
                    "type": {
                      "fields": [
                        {
                          "name": "id",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "bet_amount",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "token_address",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "is_completed",
                          "type": {
                            "kind": "boolean"
                          }
                        },
                        {
                          "name": "blocktime",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "player2_address",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "player2_move",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "game_note::GameNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::_add_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::_add_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::resolve_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::resolve_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_timeout",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::set_timeout_blocks_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::set_timeout_blocks_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player1_move",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player1_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::_resolve_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::_resolve_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "timeout_blocks",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "RockPaperScissors::get_games_length_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::get_games_length_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::get_game_by_id_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "bet_amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "is_completed",
                    "type": {
                      "kind": "boolean"
                    }
                  },
                  {
                    "name": "blocktime",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player2_address",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player2_move",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "game_note::GameNote"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::get_game_by_id_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "game_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "player1_move",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "bet_amount",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "token_addr",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "RockPaperScissors::start_game_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::start_game_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "RockPaperScissors::get_timeout_blocks_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "RockPaperScissors::get_timeout_blocks_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\nfn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/note/discovery/mod.nr",
      "source": "use std::static_assert;\n\nuse crate::{\n    context::unconstrained_context::UnconstrainedContext, note::note_header::NoteHeader,\n    oracle::note_discovery::deliver_note, utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    hash::compute_note_hash_nonce,\n};\n\n// We reserve two fields in the note log that are not part of the note content: one for the storage slot, and one for\n// the note type id.\nglobal NOTE_LOG_RESERVED_FIELDS: u32 = 2;\npub global MAX_NOTE_SERIALIZED_LEN: u32 = PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_LOG_RESERVED_FIELDS;\n\npub struct NoteHashesAndNullifier {\n    pub note_hash: Field,\n    pub unique_note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Processes a log given its plaintext by trying to find notes encoded in it. This process involves the discovery of\n/// the nonce of any such notes, which requires knowledge of the transaction hash in which the notes would've been\n/// created, along with the list of unique note hashes in said transaction.\n///\n/// Additionally, this requires a `compute_note_hash_and_nullifier` lambda that is able to compute these values for any\n/// note in the contract given their contents. A typical implementation of such a function would look like this:\n///\n/// ```\n/// |serialized_note_content, note_header, note_type_id| {\n///     let hashes = if note_type_id == MyNoteType::get_note_type_id() {\n///         assert(serialized_note_content.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///         dep::aztec::note::utils::compute_note_hash_and_optionally_a_nullifier(\n///             MyNoteType::deserialize_content,\n///             note_header,\n///             true,\n///             serialized_note_content.storage(),\n///         )\n///     } else {\n///         panic(f\"Unknown note type id {note_type_id}\")\n///     };\n///\n///     Option::some(dep::aztec::oracle::management::NoteHashesAndNullifier {\n///         note_hash: hashes[0],\n///         unique_note_hash: hashes[1],\n///         inner_nullifier: hashes[3],\n///     })\n/// }\n/// ```\npub unconstrained fn do_process_log<Env>(\n    context: UnconstrainedContext,\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: fn[Env](BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>, NoteHeader, Field) -> Option<NoteHashesAndNullifier>,\n) {\n    let (storage_slot, note_type_id, serialized_note_content) =\n        destructure_log_plaintext(log_plaintext);\n\n    // We need to find the note's nonce, which is the one that results in one of the unique note hashes from tx_hash\n    for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            let header = NoteHeader::new(context.this_address(), candidate_nonce, storage_slot);\n\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                serialized_note_content,\n                header,\n                note_type_id,\n            )\n                .unwrap();\n\n            if hashes.unique_note_hash == expected_unique_note_hash {\n                // TODO(#10726): push these into a vec to deliver all at once instead of having one oracle call per note\n\n                assert(\n                    deliver_note(\n                        context.this_address(), // TODO(#10727): allow other contracts to deliver notes\n                        storage_slot,\n                        candidate_nonce,\n                        serialized_note_content,\n                        hashes.note_hash,\n                        hashes.inner_nullifier,\n                        tx_hash,\n                        recipient,\n                    ),\n                    \"Failed to deliver note\",\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n}\n\nunconstrained fn destructure_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>) {\n    assert(log_plaintext.len() >= NOTE_LOG_RESERVED_FIELDS);\n\n    // If NOTE_LOG_RESERVED_FIELDS is changed, causing the assertion below to fail, then the declarations for\n    // `storage_slot` and `note_type_id` must be updated as well.\n    static_assert(\n        NOTE_LOG_RESERVED_FIELDS == 2,\n        \"unepxected value for NOTE_LOG_RESERVED_FIELDS\",\n    );\n    let storage_slot = log_plaintext.get(0);\n    let note_type_id = log_plaintext.get(1);\n\n    let serialized_note_content = array::subbvec(log_plaintext, NOTE_LOG_RESERVED_FIELDS);\n\n    (storage_slot, note_type_id, serialized_note_content)\n}\n\nfn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..MaxLen {\n        if i < vec.len() {\n            f(vec.get_unchecked(i), i);\n        }\n    }\n}\n"
    },
    "110": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_header::NoteHeader,\n    note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_nullify_internal, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "112": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    pub note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "114": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, NoteStatus, PropertySelector, Select, Sort, SortOrder},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\nuse dep::protocol_types::constants::{\n    GET_NOTES_ORACLE_RETURN_LENGTH, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n};\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len() {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len() {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    /// Safety: Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do\n    /// is check that the metadata is correct, and that the note exists.\n    let note = unsafe { get_note_internal(storage_slot) };\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    /// Safety: The notes are constrained below.\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::array::collapse(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len() {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len() {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n"
    },
    "120": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n    utils::array,\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    compute_unique_note_hash,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let header = note.get_header();\n    let nonce = header.nonce;\n    let counter = header.note_hash_counter;\n\n    // If same tx note, read request always uses the normal note hash\n    if counter != 0 {\n        note_hash\n    } else {\n        // If the note comes from a different tx, we need to compute the note hash that reached the tree\n        compute_unique_note_hash(\n            nonce,\n            compute_siloed_note_hash(header.contract_address, note_hash),\n        )\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if (header.note_hash_counter != 0) & (header.nonce != 0) {\n        // Non-revertible note, nullified by a revertible nullifier, we need to nullify the note hash that will reach the tree\n        let siloed_note_hash =\n            compute_siloed_note_hash(header.contract_address, note_hash_for_read_request);\n\n        compute_unique_note_hash(header.nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(array::subarray(serialized_note, 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, note_hash);\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, siloed_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "123": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "124": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "125": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\n/// Stores values represented as array in execution cache to be later obtained by its hash.\npub fn store_array<let N: u32>(values: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_array_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn store_array_in_execution_cache_oracle_wrapper<let N: u32>(values: [Field; N]) {\n    let _ = store_array_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(storeArrayInExecutionCache)]\nunconstrained fn store_array_in_execution_cache_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "126": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    /// Safety: The to_address function combines all values in the instance object to produce an address,\n    /// so by checking that we get the expected address we validate the entire struct.\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    /// Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "131": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "132": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "135": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/note_discovery.nr",
      "source": "use crate::note::discovery::MAX_NOTE_SERIALIZED_LEN;\nuse dep::protocol_types::address::AztecAddress;\n\n/// Informs PXE of a note's existence so that it can later retrieved by the `getNotes` oracle. The note will be scoped\n/// to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The note's `content` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value is\n/// typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are the\n/// inner hashes, i.e. the raw hashes returned by `NoteInterface::compute_note_hash` and\n/// `NullifiableNote::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree at\n/// `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was sucessfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        content,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    content: BoundedVec<Field, MAX_NOTE_SERIALIZED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n"
    },
    "136": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{note::{note_header::NoteHeader, note_interface::NoteInterface}, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    let _ = notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    sync_notes_oracle_wrapper();\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let note_content = array::subarray(fields, read_offset + 2);\n\n            let mut note = Note::deserialize_content(note_content);\n            note.set_header(NoteHeader { contract_address, nonce, storage_slot, note_hash_counter });\n\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them available\n/// for later querying via the `get_notes` oracle.\npub fn sync_notes() {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe {\n        sync_notes_oracle_wrapper();\n    }\n}\n\nunconstrained fn sync_notes_oracle_wrapper() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n"
    },
    "138": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "142": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "146": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/state_vars/private_mutable.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize},\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateMutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nmod test;\n\nimpl<T, Context, let N: u32> Storage<T, N> for PrivateMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateMutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateMutable>` type (for example), because the storage slot often also identifies an actor. e.g.\n    // the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    // Note: subsequent nullification of this state variable, via the `replace` method will not be leaky, if the `compute_nullifier()` method of the underlying note is designed to ensure privacy.\n    // For example, if the `compute_nullifier()` method injects the secret key of a note owner into the computed nullifier's preimage.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, &mut PrivateContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    // docs:start:initialize\n    pub fn initialize(self, note: &mut Note) -> NoteEmission<Note> {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:replace\n    pub fn replace(self, new_note: &mut Note) -> NoteEmission<Note> {\n        let (prev_note, note_hash_for_read_request): (Note, Field) =\n            get_note(self.context, self.storage_slot);\n\n        // Nullify previous note.\n        destroy_note_unsafe(self.context, prev_note, note_hash_for_read_request);\n\n        // Add replacement note.\n        create_note(self.context, self.storage_slot, new_note)\n    }\n    // docs:end:replace\n\n    pub fn initialize_or_replace(self, note: &mut Note) -> NoteEmission<Note> {\n        /// Safety: `check_nullifier_exists` is an unconstrained function - we can constrain a true value\n        /// by providing an inclusion proof of the nullifier, but cannot constrain a false value since\n        /// a non-inclusion proof would only be valid if done in public.\n        /// Ultimately, this is not an issue given that we'll either:\n        ///  - initialize the state variable, which would fail if it was already initialized due to the duplicate\n        ///    nullifier, or\n        ///  - replace the current value, which would fail if it was not initialized since we wouldn't be able\n        ///    to produce an inclusion proof for the current note\n        /// This means that an honest oracle will assist the prover to produce a valid proof, while a malicious\n        /// oracle (i.e. one that returns an incorrect value for is_initialized) will simply fail to produce\n        /// a proof.\n        let is_initialized =\n            unsafe { check_nullifier_exists(self.compute_initialization_nullifier()) };\n\n        if (!is_initialized) {\n            self.initialize(note)\n        } else {\n            self.replace(note)\n        }\n    }\n\n    // docs:start:get_note\n    pub fn get_note(self) -> NoteEmission<Note> {\n        let mut (note, note_hash_for_read_request) = get_note(self.context, self.storage_slot);\n\n        // Nullify current note to make sure it's reading the latest note.\n        destroy_note_unsafe(self.context, note, note_hash_for_read_request);\n\n        // Add the same note again.\n        // Because a nonce is added to every note in the kernel, its nullifier will be different.\n        create_note(self.context, self.storage_slot, &mut note)\n    }\n    // docs:end:get_note\n}\n\nimpl<Note, let N: u32> PrivateMutable<Note, UnconstrainedContext>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n\n    // docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"
    },
    "149": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n};\nuse dep::protocol_types::{\n    constants::INITIALIZATION_SLOT_SEPARATOR,\n    traits::{Deserialize, Serialize},\n};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicImmutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    pub fn read(self) -> T {\n        let header = self.context.get_block_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] = header.public_storage_historical_read(\n                self.storage_slot + i as Field,\n                (*self.context).this_address(),\n            );\n        }\n        T::deserialize(fields)\n    }\n}\n"
    },
    "150": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "17": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "170": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "171": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    vec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(vec.storage(), offset), vec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "172": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/utils/bytes.nr",
      "source": "// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 bytes.\n//\n// Each 31 byte chunk is converted into a Field as if the chunk was the Field's big endian representation. If the last chunk\n// is less than 31 bytes long, then only the relevant bytes are conisdered.\n// For example, [1, 10, 3] is encoded as [1 * 256^2 + 10 * 256 + 3]\npub fn bytes_to_fields<let N: u32>(input: [u8; N]) -> [Field; (N + 30) / 31] {\n    let mut dst = [0; (N + 30) / 31];\n\n    for dst_index in 0..((N + 30) / 31) {\n        let mut field_value = 0;\n\n        for i in 0..31 {\n            let byte_index = dst_index * 31 + i;\n            if byte_index < N {\n                // Shift the existing value left by 8 bits and add the new byte\n                field_value = field_value * 256 + input[byte_index] as Field;\n            }\n        }\n\n        dst[dst_index] = field_value;\n    }\n\n    dst\n}\n\n// Converts an input array of fields into bytes. Each field of input has to contain only 31 bytes.\n// TODO(#8618): Optimize for public use.\npub fn fields_to_bytes<let N: u32, let M: u32>(input: [Field; M]) -> [u8; N] {\n    let mut dst = [0; N];\n\n    for src_index in 0..M {\n        let field = input[src_index];\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let src: [u8; 31] = field.to_be_bytes();\n\n        // Since some of the bytes might not be occupied (if the source value requiring less than 31 bytes),\n        // we have to compute the start index from which to copy.\n        let remaining_bytes = N - src_index * 31;\n        let src_start_index = if remaining_bytes < 31 {\n            // If the remaining bytes are less than 31, we only copy the remaining bytes\n            31 - remaining_bytes\n        } else {\n            0\n        };\n\n        // Note: I tried combining this check with `assert_max_bit_size` above but `assert_max_bit_size` expects\n        // the argument to be a constant. Using comptime block to derive the number of bits also does not work\n        // because comptime is evaluated before generics.\n        for i in 0..src_start_index {\n            assert(src[i] == 0, \"Field does not fit into remaining bytes\");\n        }\n\n        for i in 0..31 {\n            let byte_index = src_index * 31 + i;\n            if byte_index < N {\n                dst[byte_index] = src[src_start_index + i];\n            }\n        }\n    }\n\n    dst\n}\n\nmod test {\n    use crate::utils::bytes::{bytes_to_fields, fields_to_bytes};\n\n    #[test]\n    fn test_bytes_to_1_field() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n    }\n\n    #[test]\n    fn test_1_field_to_bytes() {\n        let input = [0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f];\n        let output: [u8; 31] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 93] = fields_to_bytes(input);\n\n        // Each field should occupy 31 bytes with the non-zero value being placed in the last one.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 0, 0, 0, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_3_small_fields_to_less_bytes() {\n        let input = [1, 2, 3];\n        let output: [u8; 63] = fields_to_bytes(input);\n\n        // First 2 fields should occupy 31 bytes with the non-zero value being placed in the last one while the last\n        // field should occupy 1 byte. There is not information destruction here because the last field fits into\n        // 1 byte.\n        assert_eq(\n            output,\n            [\n                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n                0, 0, 0, 0, 0, 2, 3,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_bytes_to_2_fields() {\n        let input = [\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        ];\n        let output = bytes_to_fields(input);\n\n        assert_eq(output[0], 0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f);\n        assert_eq(output[1], 0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b);\n    }\n\n    #[test]\n    fn test_2_fields_to_bytes() {\n        let input = [\n            0x0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f,\n            0x202122232425262728292a2b2c2d2e2f303132333435363738393a3b,\n        ];\n        let output: [u8; 62] = fields_to_bytes(input);\n\n        assert_eq(\n            output,\n            [\n                1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n                24, 25, 26, 27, 28, 29, 30, 31, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n            ],\n        );\n    }\n\n    #[test]\n    fn test_large_random_input_to_fields_and_back(input: [u8; 128]) {\n        let output = bytes_to_fields(input);\n        let input_back: [u8; 128] = fields_to_bytes(output);\n\n        assert_eq(input, input_back);\n    }\n\n    // I need to get an array of random values lower than 2^248 on input and since there is no u248 type and modulo\n    // operation is not supported on a Field (to do field % 2^248), I will take multiple smaller values and combine\n    // them to get a value lower than 2^248.\n    #[test]\n    fn test_large_random_input_to_bytes_and_back(\n        input1: [u64; 5],\n        input2: [u64; 5],\n        input3: [u64; 5],\n        input4: [u32; 5],\n        input5: [u16; 5],\n        input6: [u8; 5],\n    ) {\n        let mut input = [0; 5];\n        for i in 0..5 {\n            input[i] = (input1[i] as Field * 2.pow_32(184))\n                + (input2[i] as Field * 2.pow_32(120))\n                + (input3[i] as Field * 2.pow_32(56))\n                + (input4[i] as Field * 2.pow_32(24))\n                + (input5[i] as Field * 2.pow_32(8))\n                + input6[i] as Field;\n        }\n\n        let output: [u8; 155] = fields_to_bytes(input);\n        let input_back = bytes_to_fields(output);\n\n        assert_eq(input, input_back);\n    }\n\n    #[test(should_fail_with = \"Field does not fit into remaining bytes\")]\n    fn test_too_few_destination_bytes() {\n        // We should get an error here because first field gets converted to 31 bytes and the second field needs\n        // at least 2 bytes but we provide it with 1.\n        let input = [1, 256];\n        let _ignored_result: [u8; 32] = fields_to_bytes(input);\n    }\n\n    #[test(should_fail_with = \"call to assert_max_bit_size\")]\n    fn test_fields_to_bytes_value_too_large() {\n        let input = [2.pow_32(248)];\n        let _ignored_result: [u8; 31] = fields_to_bytes(input);\n    }\n\n    #[test]\n    fn test_fields_to_bytes_max_value() {\n        let input = [2.pow_32(248) - 1];\n        let result: [u8; 31] = fields_to_bytes(input);\n\n        // We check that all the bytes were set to max value (255)\n        for i in 0..31 {\n            assert_eq(result[i], 255);\n        }\n    }\n}\n"
    },
    "175": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use crate::utils::point::point_to_bytes;\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "19": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "193": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "21": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    /// Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "227": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pub pk_m: Point,\n    pub sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"
    },
    "234": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse ec::{pow, sqrt};\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        function_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            function_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "250": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    /// Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    /// to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "251": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::{constants::TWO_POW_64, utils::{arrays::array_concat, field::field_from_bytes}};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\npub fn compute_tx_logs_hash<let N: u32>(logs: [LogHash; N]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; N * 32];\n    for offset in 0..N {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut contructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(contructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == contructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "252": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/indexed_tagging_secret.nr",
      "source": "use crate::traits::{Deserialize, Serialize, ToField};\nuse super::{address::aztec_address::AztecAddress, hash::poseidon2_hash};\nuse std::meta::derive;\n\npub global INDEXED_TAGGING_SECRET_LENGTH: u32 = 2;\n\n#[derive(Serialize, Deserialize)]\npub struct IndexedTaggingSecret {\n    app_tagging_secret: Field,\n    index: u32,\n}\n\nimpl IndexedTaggingSecret {\n    pub fn compute_tag(self, recipient: AztecAddress) -> Field {\n        poseidon2_hash(\n            [self.app_tagging_secret, recipient.to_field(), self.index as Field],\n        )\n    }\n}\n"
    },
    "26": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "267": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "268": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "27": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n"
    },
    "277": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "280": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "293": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "297": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        /// Safety: `sorted` array is checked to be:\n        /// a. a permutation of `input`'s elements\n        /// b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"
    },
    "313": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    /// Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    /// of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "316": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "321": {
      "path": "/Users/lago/nargo/github.com/noir-lang/ec/v0.1.2/src/lib.nr",
      "source": "// Elliptic curve implementation\n// Overview\n// ========\n// The following three elliptic curve representations are admissible:\npub mod tecurve; // Twisted Edwards curves\npub mod swcurve; // Elliptic curves in Short Weierstrass form\npub mod montcurve; // Montgomery curves\npub mod consts; // Commonly used curve presets\n//\n// Note that Twisted Edwards and Montgomery curves are (birationally) equivalent, so that\n// they may be freely converted between one another, whereas Short Weierstrass curves are\n// more general. Diagramatically:\n//\n// tecurve == montcurve `subset` swcurve\n//\n// Each module is further divided into two submodules, 'affine' and 'curvegroup', depending\n// on the preferred coordinate representation. Affine coordinates are none other than the usual\n// two-dimensional Cartesian coordinates used in the definitions of these curves, whereas\n// 'CurveGroup' coordinates (terminology borrowed from Arkworks, whose conventions we try\n// to follow) are special coordinate systems with respect to which the group operations may be\n// implemented more efficiently, usually by means of an appropriate choice of projective coordinates.\n//\n// In each of these submodules, there is a Point struct and a Curve struct, the former\n// representing a point in the coordinate system and the latter a curve configuration.\n//\n// Points\n// ======\n// Points may be instantiated using the associated function `new`, which takes coordinates\n// as its arguments. For instance,\n//\n// `let p = swcurve::Point::new(1,1);`\n//\n// The additive identity may be constructed by a call to the associated function `zero` of no\n// arguments:\n//\n// `let zero = swcurve::Point::zero();`\n//\n// Points may be tested for equality by calling the method `eq`:\n//\n// `let pred = p.eq(zero);`\n//\n// There is also the method `is_zero` to explicitly check whether a point is the additive identity:\n//\n// `constrain pred == p.is_zero();`\n//\n// Points may be negated by calling the `negate` method and converted to CurveGroup (or affine)\n// coordinates by calling the `into_group` (resp. `into_affine`) method on them. Finally,\n// Points may be freely mapped between their respective Twisted Edwards and Montgomery\n// representations by calling the `into_montcurve` or `into_tecurve` methods. For mappings\n// between Twisted Edwards/Montgomery curves and Short Weierstrass curves, see the Curve section\n// below, as the underlying mappings are those of curves rather than ambient spaces.\n// As a rule, Points in affine (or CurveGroup) coordinates are mapped to Points in affine\n// (resp. CurveGroup) coordinates.\n//\n// Curves\n// ======\n// A curve configuration (Curve) is completely determined by the Field coefficients of its defining\n// equation (a and b in the case of swcurve, a and d in the case of tecurve, and j and k in\n// the case of montcurve) together with a generator (`gen`) in the corresponding coordinate system.\n// For example, the Baby Jubjub curve configuration as defined in ERC-2494 may be instantiated as a Twisted\n// Edwards curve in affine coordinates as follows:\n//\n// `let bjj_affine = tecurve::Curve::new(168700, 168696, tecurve::Point::new(995203441582195749578291179787384436505546430278305826713579947235728471134,5472060717959818805561601436314318772137091100104008585924551046643952123905));`\n//\n// The `contains` method may be used to check whether a Point lies on a given curve:\n//\n// `constrain bjj_affine.contains(tecurve::Point::zero());`\n//\n// The elliptic curve group's addition operation is exposed as the `add` method, e.g.\n//\n// `let p = bjj_affine.add(bjj_affine.gen, bjj_affine.gen);`\n//\n// subtraction as the `subtract` method, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.subtract(bjj_affine.gen, bjj_affine.gen));`\n//\n// scalar multiplication as the `mul` method, where the scalar is assumed to be a Field* element, e.g.\n//\n// `constrain tecurve::Point::zero().eq(bjj_affine.mul(2, tecurve::Point::zero());`\n//\n// There is a scalar multiplication method (`bit_mul`) provided where the scalar input is expected to be\n// an array of bits (little-endian convention), as well as a multi-scalar multiplication method** (`msm`)\n// which takes an array of Field elements and an array of elliptic curve points as arguments, both assumed\n// to be of the same length.\n//\n// Curve configurations may be converted between different coordinate representations by calling the `into_group`\n// and `into_affine` methods on them, e.g.\n//\n// `let bjj_curvegroup = bjj_affine.into_group();`\n//\n// Curve configurations may also be converted between different curve representations by calling the `into_swcurve`,\n// `into_montcurve` and `into_tecurve` methods subject to the relation between the curve representations mentioned\n// above. Note that it is possible to map Points from a Twisted Edwards/Montgomery curve to the corresponding\n// Short Weierstrass representation and back, and the methods to do so are exposed as `map_into_swcurve` and\n// `map_from_swcurve`, which each take one argument, the point to be mapped.\n//\n// Curve maps\n// ==========\n// There are a few different ways of mapping Field elements to elliptic curves. Here we provide the simplified\n// Shallue-van de Woestijne-Ulas and Elligator 2 methods, the former being applicable to all curve types\n// provided above subject to the constraint that the coefficients of the corresponding Short Weierstrass curve satisfies\n// a*b != 0 and the latter being applicable to Montgomery and Twisted Edwards curves subject to the constraint that\n// the coefficients of the corresponding Montgomery curve satisfy j*k != 0 and (j^2 - 4)/k^2 is non-square.\n//\n// The simplified Shallue-van de Woestijne-Ulas method is exposed as the method `swu_map` on the Curve configuration and\n// depends on two parameters, a Field element z != -1 for which g(x) - z is irreducible over Field and g(b/(z*a)) is\n// square, where g(x) = x^3 + a*x + b is the right-hand side of the defining equation of the corresponding Short\n// Weierstrass curve, and a Field element u to be mapped onto the curve. For example, in the case of bjj_affine above,\n// it may be determined using the scripts provided at <https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve> that z = 5.\n//\n// The Elligator 2 method is exposed as the method `elligator2_map` on the Curve configurations of Montgomery and\n// Twisted Edwards curves. Like the simplified SWU method above, it depends on a certain non-square element of Field,\n// but this element need not satisfy any further conditions, so it is included as the (Field-dependent) constant\n//`ZETA` below. Thus, the `elligator2_map` method depends only on one parameter, the Field element to be mapped onto\n// the curve.\n//\n// For details on all of the above in the context of hashing to elliptic curves, see <https://datatracker.ietf.org/doc/id/draft-irtf-cfrg-hash-to-curve-06.html>.\n//\n//\n// *TODO: Replace Field with Bigint.\n// **TODO: Support arrays of structs to make this work.\n// Field-dependent constant ZETA = a non-square element of Field\n// Required for Elligator 2 map\n// TODO: Replace with built-in constant.\nglobal ZETA: Field = 5;\n// Field-dependent constants for Tonelli-Shanks algorithm (see sqrt function below)\n// TODO: Possibly make this built-in.\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n// Higher-order version of scalar multiplication\n// TODO: Make this work so that the submodules' bit_mul may be defined in terms of it.\n//fn bit_mul<T,N>(add: fn(T,T) -> T, e: T, bits: [u1; N], p: T) -> T {\n//    let mut out = e;\n//    let n = bits.len();\n//\n//    for i in 0..n {\n//        out = add(\n//            add(out, out),\n//            if(bits[n - i - 1] == 0) {e} else {p});\n//    }\n//\n//    out\n//}\n// TODO: Make this built-in.\npub fn safe_inverse(x: Field) -> Field {\n    if x == 0 {\n        0\n    } else {\n        1 / x\n    }\n}\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\npub fn is_square(x: Field) -> bool {\n    let v = pow(x, 0 - 1 / 2);\n\n    v * (v - 1) == 0\n}\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\nmod tests {\n    use crate::montcurve::affine::Point as MGaffine;\n    use crate::montcurve::curvegroup::Point as MG;\n    use crate::swcurve::affine::Point as SWGaffine;\n    use crate::swcurve::curvegroup::Point as SWG;\n    use crate::tecurve::affine::Curve as AffineCurve;\n    use crate::tecurve::affine::Point as Gaffine;\n    use crate::tecurve::curvegroup::Point as G;\n\n    #[test]\n    fn smoke_test() {\n        // Tests may be checked against https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve/tree/main/poc\n        // Define Baby Jubjub (ERC-2494) parameters in affine representation\n        let bjj_affine = AffineCurve::new(\n            168700,\n            168696,\n            Gaffine::new(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905,\n            ),\n        );\n        // Test addition\n        let p1_affine = Gaffine::new(\n            17777552123799933955779906779655732241715742912184938656739573121738514868268,\n            2626589144620713026669568689430873010625803728049924121243784502389097019475,\n        );\n        let p2_affine = Gaffine::new(\n            16540640123574156134436876038791482806971768689494387082833631921987005038935,\n            20819045374670962167435360035096875258406992893633759881276124905556507972311,\n        );\n\n        let p3_affine = bjj_affine.add(p1_affine, p2_affine);\n        assert(p3_affine.eq(Gaffine::new(\n            7916061937171219682591368294088513039687205273691143098332585753343424131937,\n            14035240266687799601661095864649209771790948434046947201833777492504781204499,\n        )));\n        // Test scalar multiplication\n        let p4_affine = bjj_affine.mul(2, p1_affine);\n        assert(p4_affine.eq(Gaffine::new(\n            6890855772600357754907169075114257697580319025794532037257385534741338397365,\n            4338620300185947561074059802482547481416142213883829469920100239455078257889,\n        )));\n        assert(p4_affine.eq(bjj_affine.bit_mul([0, 1], p1_affine)));\n        // Test subtraction\n        let p5_affine = bjj_affine.subtract(p3_affine, p3_affine);\n        assert(p5_affine.eq(Gaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_affine.contains(bjj_affine.gen)\n                & bjj_affine.contains(p1_affine)\n                & bjj_affine.contains(p2_affine)\n                & bjj_affine.contains(p3_affine)\n                & bjj_affine.contains(p4_affine)\n                & bjj_affine.contains(p5_affine),\n        );\n        // Test CurveGroup equivalents\n        let bjj = bjj_affine.into_group(); // Baby Jubjub\n        let p1 = p1_affine.into_group();\n        let p2 = p2_affine.into_group();\n        let p3 = p3_affine.into_group();\n        let p4 = p4_affine.into_group();\n        let p5 = p5_affine.into_group();\n        // Test addition\n        assert(p3.eq(bjj.add(p1, p2)));\n        // Test scalar multiplication\n        assert(p4.eq(bjj.mul(2, p1)));\n        assert(p4.eq(bjj.bit_mul([0, 1], p1)));\n        // Test subtraction\n        assert(G::zero().eq(bjj.subtract(p3, p3)));\n        assert(p5.eq(G::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj.contains(bjj.gen)\n                & bjj.contains(p1)\n                & bjj.contains(p2)\n                & bjj.contains(p3)\n                & bjj.contains(p4)\n                & bjj.contains(p5),\n        );\n        // Test SWCurve equivalents of the above\n        // First the affine representation\n        let bjj_swcurve_affine = bjj_affine.into_swcurve();\n\n        let p1_swcurve_affine = bjj_affine.map_into_swcurve(p1_affine);\n        let p2_swcurve_affine = bjj_affine.map_into_swcurve(p2_affine);\n        let p3_swcurve_affine = bjj_affine.map_into_swcurve(p3_affine);\n        let p4_swcurve_affine = bjj_affine.map_into_swcurve(p4_affine);\n        let p5_swcurve_affine = bjj_affine.map_into_swcurve(p5_affine);\n        // Addition\n        assert(p3_swcurve_affine.eq(bjj_swcurve_affine.add(p1_swcurve_affine, p2_swcurve_affine)));\n        // Doubling\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.mul(2, p1_swcurve_affine)));\n        assert(p4_swcurve_affine.eq(bjj_swcurve_affine.bit_mul([0, 1], p1_swcurve_affine)));\n        // Subtraction\n        assert(SWGaffine::zero().eq(bjj_swcurve_affine.subtract(\n            p3_swcurve_affine,\n            p3_swcurve_affine,\n        )));\n        assert(p5_swcurve_affine.eq(SWGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve_affine.contains(bjj_swcurve_affine.gen)\n                & bjj_swcurve_affine.contains(p1_swcurve_affine)\n                & bjj_swcurve_affine.contains(p2_swcurve_affine)\n                & bjj_swcurve_affine.contains(p3_swcurve_affine)\n                & bjj_swcurve_affine.contains(p4_swcurve_affine)\n                & bjj_swcurve_affine.contains(p5_swcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_swcurve = bjj.into_swcurve();\n\n        let p1_swcurve = bjj.map_into_swcurve(p1);\n        let p2_swcurve = bjj.map_into_swcurve(p2);\n        let p3_swcurve = bjj.map_into_swcurve(p3);\n        let p4_swcurve = bjj.map_into_swcurve(p4);\n        let p5_swcurve = bjj.map_into_swcurve(p5);\n        // Addition\n        assert(p3_swcurve.eq(bjj_swcurve.add(p1_swcurve, p2_swcurve)));\n        // Doubling\n        assert(p4_swcurve.eq(bjj_swcurve.mul(2, p1_swcurve)));\n        assert(p4_swcurve.eq(bjj_swcurve.bit_mul([0, 1], p1_swcurve)));\n        // Subtraction\n        assert(SWG::zero().eq(bjj_swcurve.subtract(p3_swcurve, p3_swcurve)));\n        assert(p5_swcurve.eq(SWG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_swcurve.contains(bjj_swcurve.gen)\n                & bjj_swcurve.contains(p1_swcurve)\n                & bjj_swcurve.contains(p2_swcurve)\n                & bjj_swcurve.contains(p3_swcurve)\n                & bjj_swcurve.contains(p4_swcurve)\n                & bjj_swcurve.contains(p5_swcurve),\n        );\n        // Test MontCurve conversions\n        // First the affine representation\n        let bjj_montcurve_affine = bjj_affine.into_montcurve();\n\n        let p1_montcurve_affine = p1_affine.into_montcurve();\n        let p2_montcurve_affine = p2_affine.into_montcurve();\n        let p3_montcurve_affine = p3_affine.into_montcurve();\n        let p4_montcurve_affine = p4_affine.into_montcurve();\n        let p5_montcurve_affine = p5_affine.into_montcurve();\n        // Addition\n        assert(p3_montcurve_affine.eq(bjj_montcurve_affine.add(\n            p1_montcurve_affine,\n            p2_montcurve_affine,\n        )));\n        // Doubling\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.mul(2, p1_montcurve_affine)));\n        assert(p4_montcurve_affine.eq(bjj_montcurve_affine.bit_mul([0, 1], p1_montcurve_affine)));\n        // Subtraction\n        assert(MGaffine::zero().eq(bjj_montcurve_affine.subtract(\n            p3_montcurve_affine,\n            p3_montcurve_affine,\n        )));\n        assert(p5_montcurve_affine.eq(MGaffine::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve_affine.contains(bjj_montcurve_affine.gen)\n                & bjj_montcurve_affine.contains(p1_montcurve_affine)\n                & bjj_montcurve_affine.contains(p2_montcurve_affine)\n                & bjj_montcurve_affine.contains(p3_montcurve_affine)\n                & bjj_montcurve_affine.contains(p4_montcurve_affine)\n                & bjj_montcurve_affine.contains(p5_montcurve_affine),\n        );\n        // Then the CurveGroup representation\n        let bjj_montcurve = bjj.into_montcurve();\n\n        let p1_montcurve = p1_montcurve_affine.into_group();\n        let p2_montcurve = p2_montcurve_affine.into_group();\n        let p3_montcurve = p3_montcurve_affine.into_group();\n        let p4_montcurve = p4_montcurve_affine.into_group();\n        let p5_montcurve = p5_montcurve_affine.into_group();\n        // Addition\n        assert(p3_montcurve.eq(bjj_montcurve.add(p1_montcurve, p2_montcurve)));\n        // Doubling\n        assert(p4_montcurve.eq(bjj_montcurve.mul(2, p1_montcurve)));\n        assert(p4_montcurve.eq(bjj_montcurve.bit_mul([0, 1], p1_montcurve)));\n        // Subtraction\n        assert(MG::zero().eq(bjj_montcurve.subtract(p3_montcurve, p3_montcurve)));\n        assert(p5_montcurve.eq(MG::zero()));\n        // Check that these points are on the curve\n        assert(\n            bjj_montcurve.contains(bjj_montcurve.gen)\n                & bjj_montcurve.contains(p1_montcurve)\n                & bjj_montcurve.contains(p2_montcurve)\n                & bjj_montcurve.contains(p3_montcurve)\n                & bjj_montcurve.contains(p4_montcurve)\n                & bjj_montcurve.contains(p5_montcurve),\n        );\n        // Elligator 2 map-to-curve\n        let ell2_pt_map = bjj_affine.elligator2_map(27);\n\n        assert(ell2_pt_map.eq(MGaffine::new(\n            7972459279704486422145701269802978968072470631857513331988813812334797879121,\n            8142420778878030219043334189293412482212146646099536952861607542822144507872,\n        )\n            .into_tecurve()));\n        // SWU map-to-curve\n        let swu_pt_map = bjj_affine.swu_map(5, 27);\n\n        assert(swu_pt_map.eq(bjj_affine.map_from_swcurve(SWGaffine::new(\n            2162719247815120009132293839392097468339661471129795280520343931405114293888,\n            5341392251743377373758788728206293080122949448990104760111875914082289313973,\n        ))));\n    }\n\n}\n"
    },
    "325": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr",
      "source": "// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n#[aztec]\ncontract Token {\n    // Libs\n    use std::meta::derive;\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        context::{PrivateCallInterface, PrivateContext},\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::{\n                encode_and_encrypt_note, encode_and_encrypt_note_unconstrained,\n            },\n        },\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, view},\n            storage::storage,\n        },\n        oracle::random::random,\n        prelude::{\n            AztecAddress, FunctionSelector, Map, PublicContext, PublicImmutable, PublicMutable,\n        },\n        protocol_types::{point::Point, traits::Serialize},\n    };\n\n    use dep::uint_note::uint_note::UintNote;\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{\n        assert_current_call_valid_authwit, assert_current_call_valid_authwit_public,\n        compute_authwit_nullifier,\n    };\n    // docs:end:import_authwit\n\n    use crate::types::balance_set::BalanceSet;\n\n    // docs:end::imports\n\n    // In the first transfer iteration we are computing a lot of additional information (validating inputs, retrieving\n    // keys, etc.), so the gate count is already relatively high. We therefore only read a few notes to keep the happy\n    // case with few constraints.\n    global INITIAL_TRANSFER_CALL_MAX_NOTES: u32 = 2;\n    // All the recursive call does is nullify notes, meaning the gate count is low, but it is all constant overhead. We\n    // therefore read more notes than in the base case to increase the efficiency of the overhead, since this results in\n    // an overall small circuit regardless.\n    global RECURSIVE_TRANSFER_CALL_MAX_NOTES: u32 = 8;\n\n    #[derive(Serialize)]\n    #[event]\n    struct Transfer {\n        from: AztecAddress,\n        to: AztecAddress,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[storage]\n    struct Storage<Context> {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress, Context>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool, Context>, Context>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: Map<AztecAddress, BalanceSet<Context>, Context>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128, Context>,\n        public_balances: Map<AztecAddress, PublicMutable<U128, Context>, Context>,\n        symbol: PublicImmutable<FieldCompressedString, Context>,\n        name: PublicImmutable<FieldCompressedString, Context>,\n        // docs:start:storage_decimals\n        decimals: PublicImmutable<u8, Context>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[public]\n    #[initializer]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[public]\n    #[view]\n    fn public_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_name() -> FieldCompressedString {\n        storage.name.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read()\n    }\n\n    #[public]\n    #[view]\n    fn public_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    #[private]\n    #[view]\n    fn private_get_decimals() -> pub u8 {\n        storage.decimals.read()\n    }\n\n    // docs:start:admin\n    #[public]\n    #[view]\n    fn get_admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[public]\n    #[view]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[public]\n    #[view]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[public]\n    #[view]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[public]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_to_public\n    #[public]\n    fn mint_to_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_to_public\n\n    // docs:start:transfer_in_public\n    #[public]\n    fn transfer_in_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_in_public\n\n    // docs:start:burn_public\n    #[public]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:transfer_to_public\n    #[private]\n    fn transfer_to_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:transfer_to_public\n\n    // docs:start:transfer\n    #[private]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        let amount = U128::from_integer(amount);\n        // We reduce `from`'s balance by amount by recursively removing notes over potentially multiple calls. This\n        // method keeps the gate count for each individual call low - reading too many notes at once could result in\n        // circuits in which proving is not feasible.\n        // Since the sum of the amounts in the notes we nullified was potentially larger than amount, we create a new\n        // note for `from` with the change amount, e.g. if `amount` is 10 and two notes are nullified with amounts 8 and\n        // 5, then the change will be 3 (since 8 + 5 - 10 = 3).\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            from,\n            amount,\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        storage.balances.at(from).add(from, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            from,\n            from,\n        ));\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            to,\n            from,\n        ));\n        // We don't constrain encryption of the note log in `transfer` (unlike in `transfer_in_private`) because the transfer\n        // function is only designed to be used in situations where the event is not strictly necessary (e.g. payment to\n        // another person where the payment is considered to be successful when the other party successfully decrypts a\n        // note).\n        Transfer { from, to, amount: amount.to_field() }.emit(\n            encode_and_encrypt_event_unconstrained(&mut context, to, from),\n        );\n    }\n    // docs:end:transfer\n\n    #[contract_library_method]\n    fn subtract_balance(\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n        account: AztecAddress,\n        amount: U128,\n        max_notes: u32,\n    ) -> U128 {\n        let subtracted = storage.balances.at(account).try_sub(amount, max_notes);\n        // Failing to subtract any amount means that the owner was unable to produce more notes that could be nullified.\n        // We could in some cases fail early inside try_sub if we detected that fewer notes than the maximum were\n        // returned and we were still unable to reach the target amount, but that'd make the code more complicated, and\n        // optimizing for the failure scenario is not as important.\n        assert(subtracted > U128::from_integer(0), \"Balance too low\");\n        if subtracted >= amount {\n            // We have achieved our goal of nullifying notes that add up to more than amount, so we return the change\n            subtracted - amount\n        } else {\n            // try_sub failed to nullify enough notes to reach the target amount, so we compute the amount remaining\n            // and try again.\n            let remaining = amount - subtracted;\n            compute_recurse_subtract_balance_call(*context, account, remaining).call(context)\n        }\n    }\n\n    // TODO(#7729): apply no_predicates to the contract interface method directly instead of having to use a wrapper\n    // like we do here.\n    #[no_predicates]\n    #[contract_library_method]\n    fn compute_recurse_subtract_balance_call(\n        context: PrivateContext,\n        account: AztecAddress,\n        remaining: U128,\n    ) -> PrivateCallInterface<25, U128> {\n        Token::at(context.this_address())._recurse_subtract_balance(account, remaining.to_field())\n    }\n\n    // TODO(#7728): even though the amount should be a U128, we can't have that type in a contract interface due to\n    // serialization issues.\n    #[internal]\n    #[private]\n    fn _recurse_subtract_balance(account: AztecAddress, amount: Field) -> U128 {\n        subtract_balance(\n            &mut context,\n            storage,\n            account,\n            U128::from_integer(amount),\n            RECURSIVE_TRANSFER_CALL_MAX_NOTES,\n        )\n    }\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    // docs:start:cancel_authwit\n    #[private]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_nullifier(nullifier);\n    }\n    // docs:end:cancel_authwit\n\n    // docs:start:transfer_in_private\n    #[private]\n    fn transfer_in_private(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.at(from).sub(from, amount).emit(encode_and_encrypt_note(\n            &mut context,\n            from,\n            from,\n        ));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.at(to).add(to, amount).emit(encode_and_encrypt_note(&mut context, to, from));\n    }\n    // docs:end:transfer_in_private\n\n    // docs:start:burn_private\n    #[private]\n    fn burn_private(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        storage.balances.at(from).sub(from, U128::from_integer(amount)).emit(\n            encode_and_encrypt_note(&mut context, from, from),\n        );\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn_private\n\n    // docs:start:transfer_to_private\n    // Transfers token `amount` from public balance of message sender to a private balance of `to`.\n    #[private]\n    fn transfer_to_private(to: AztecAddress, amount: Field) {\n        // `from` is the owner of the public balance from which we'll subtract the `amount`.\n        let from = context.msg_sender();\n        let token = Token::at(context.this_address());\n\n        // We prepare the private balance increase (the partial note).\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the transfer. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that he can transfer only his own tokens.\n        token._finalize_transfer_to_private_unsafe(from, amount, hiding_point_slot).enqueue(\n            &mut context,\n        );\n    }\n    // docs:end:transfer_to_private\n\n    // docs:start:prepare_private_balance_increase\n    /// Prepares an increase of private balance of `to` (partial note). The increase needs to be finalized by calling\n    /// some of the finalization functions (`finalize_transfer_to_private`, `finalize_mint_to_private`).\n    /// Returns a hiding point slot.\n    #[private]\n    fn prepare_private_balance_increase(to: AztecAddress, from: AztecAddress) -> Field {\n        // TODO(#9887): ideally we'd not have `from` here, but we do need a `from` address to produce a tagging secret\n        // with `to`.\n        _prepare_private_balance_increase(from, to, &mut context, storage)\n    }\n    // docs:end:prepare_private_balance_increase\n\n    /// This function exists separately from `prepare_private_balance_increase` solely as an optimization as it allows\n    /// us to have it inlined in the `transfer_to_private` function which results in one less kernel iteration.\n    ///\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[contract_library_method]\n    fn _prepare_private_balance_increase(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        context: &mut PrivateContext,\n        storage: Storage<&mut PrivateContext>,\n    ) -> Field {\n        let to_note_slot = storage.balances.at(to).set.storage_slot;\n\n        // We create a setup payload with unpopulated/zero `amount` for 'to'\n        // TODO(#7775): Manually fetching the randomness here is not great. If we decide to include randomness in all\n        // notes we could just inject it in macros.\n\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let note_randomness = unsafe { random() };\n        let note_setup_payload = UintNote::setup_payload().new(to, note_randomness, to_note_slot);\n\n        // We get the keys and encrypt the log of the note\n        let setup_log = note_setup_payload.encrypt_log(context, to, from);\n\n        // Using the x-coordinate as a hiding point slot is safe against someone else interfering with it because\n        // we have a guarantee that the public functions of the transaction are executed right after the private ones\n        // and for this reason the protocol guarantees that nobody can front-run us in consuming the hiding point.\n        // This guarantee would break if `finalize_transfer_to_private` was not called in the same transaction. This\n        // however is not the flow we are currently concerned with. To support the multi-transaction flow we could\n        // introduce a `from` function argument, hash the x-coordinate with it and then repeat the hashing in\n        // `finalize_transfer_to_private`.\n        //\n        // We can also be sure that the `hiding_point_slot` will not overwrite any other value in the storage because\n        // in our state variables we derive slots using a different hash function from multi scalar multiplication\n        // (MSM).\n        let hiding_point_slot = note_setup_payload.hiding_point.x;\n\n        // We don't need to perform a check that the value overwritten by `_store_point_in_transient_storage_unsafe`\n        // is zero because the slot is the x-coordinate of the hiding point and hence we could only overwrite\n        // the value in the slot with the same value. This makes usage of the `unsafe` method safe.\n        Token::at(context.this_address())\n            ._store_payload_in_transient_storage_unsafe(\n                hiding_point_slot,\n                note_setup_payload.hiding_point,\n                setup_log,\n            )\n            .enqueue(context);\n\n        hiding_point_slot\n    }\n\n    // docs:start:finalize_transfer_to_private\n    /// Finalizes a transfer of token `amount` from public balance of `from` to a private balance of `to`.\n    /// The transfer must be prepared by calling `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    #[public]\n    fn finalize_transfer_to_private(amount: Field, hiding_point_slot: Field) {\n        let from = context.msg_sender();\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private\n\n    // docs:start:finalize_transfer_to_private_unsafe\n    /// This is a wrapper around `_finalize_transfer_to_private` placed here so that a call\n    /// to `_finalize_transfer_to_private` can be enqueued. Called unsafe as it does not check `from` (this has to be\n    /// done in the calling function).\n    #[public]\n    #[internal]\n    fn _finalize_transfer_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        _finalize_transfer_to_private(from, amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_transfer_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_transfer_to_private(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        // TODO(#8271): Type the amount as U128 and nuke the ugly cast\n        let amount = U128::from_integer(amount);\n\n        // First we subtract the `amount` from the public balance of `from`\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:mint_to_private\n    /// Mints token `amount` to a private balance of `to`. Message sender has to have minter permissions (checked\n    /// in the enqueued call).\n    #[private]\n    fn mint_to_private(\n        from: AztecAddress, // sender of the tag: TODO(#9887): this is not great?\n        to: AztecAddress,\n        amount: Field,\n    ) {\n        let token = Token::at(context.this_address());\n\n        // We prepare the partial note to which we'll \"send\" the minted amount.\n        let hiding_point_slot = _prepare_private_balance_increase(from, to, &mut context, storage);\n\n        // At last we finalize the mint. Usage of the `unsafe` method here is safe because we set the `from`\n        // function argument to a message sender, guaranteeing that only a message sender with minter permissions\n        // can successfully execute the function.\n        token\n            ._finalize_mint_to_private_unsafe(context.msg_sender(), amount, hiding_point_slot)\n            .enqueue(&mut context);\n    }\n    // docs:end:mint_to_private\n\n    // docs:start:finalize_mint_to_private\n    /// Finalizes a mint of token `amount` to a private balance of `to`. The mint must be prepared by calling\n    /// `prepare_private_balance_increase` first and the resulting\n    /// `hiding_point_slot` must be passed as an argument to this function.\n    ///\n    /// Note: This function is only an optimization as it could be replaced by a combination of `mint_to_public`\n    /// and `finalize_transfer_to_private`. It is however used very commonly so it makes sense to optimize it\n    /// (e.g. used during token bridging, in AMM liquidity token etc.).\n    #[public]\n    fn finalize_mint_to_private(amount: Field, hiding_point_slot: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private\n\n    // docs:start:finalize_mint_to_private_unsafe\n    #[public]\n    #[internal]\n    fn _finalize_mint_to_private_unsafe(\n        from: AztecAddress,\n        amount: Field,\n        hiding_point_slot: Field,\n    ) {\n        // We check the minter permissions as it was not done in `mint_to_private` function.\n        assert(storage.minters.at(from).read(), \"caller is not minter\");\n        _finalize_mint_to_private(amount, hiding_point_slot, &mut context, storage);\n    }\n    // docs:end:finalize_mint_to_private_unsafe\n\n    #[contract_library_method]\n    fn _finalize_mint_to_private(\n        amount: Field,\n        hiding_point_slot: Field,\n        context: &mut PublicContext,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let amount = U128::from_integer(amount);\n\n        // First we increase the total supply by the `amount`\n        let supply = storage.total_supply.read().add(amount);\n        storage.total_supply.write(supply);\n\n        // Then we finalize the partial note with the `amount`\n        let finalization_payload =\n            UintNote::finalization_payload().new(context, hiding_point_slot, amount);\n\n        // At last we emit the note hash and the final log\n        finalization_payload.emit();\n    }\n\n    // docs:start:setup_refund\n    /// Called by fee payer contract (FPC) to set up a refund for a user during the private fee payment flow.\n    #[private]\n    fn setup_refund(\n        user: AztecAddress, // A user for which we are setting up the fee refund.\n        max_fee: Field, // The maximum fee a user is willing to pay for the tx.\n        nonce: Field, // A nonce to make authwitness unique.\n    ) {\n        // 1. This function is called by FPC when setting up a refund so we need to support the authwit flow here\n        // and check that the user really permitted fee_recipient to set up a refund on their behalf.\n        assert_current_call_valid_authwit(&mut context, user);\n\n        // 2. Deduct the max fee from user's balance. The difference between max fee and the actual tx fee will\n        // be refunded to the user in the `complete_refund(...)` function.\n        let change = subtract_balance(\n            &mut context,\n            storage,\n            user,\n            U128::from_integer(max_fee),\n            INITIAL_TRANSFER_CALL_MAX_NOTES,\n        );\n        // Emit the change note.\n        storage.balances.at(user).add(user, change).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            user,\n            user,\n        ));\n\n        // 3. Prepare the partial note for the refund.\n        let user_point_slot = _prepare_private_balance_increase(user, user, &mut context, storage);\n\n        // 4. Set the public teardown function to `complete_refund(...)`. Public teardown is the only time when a public\n        // function has access to the final transaction fee, which is needed to compute the actual refund amount.\n        let fee_recipient = context.msg_sender(); // FPC is the fee recipient.\n        context.set_public_teardown_function(\n            context.this_address(),\n            comptime { FunctionSelector::from_signature(\"complete_refund((Field),Field,Field)\") },\n            [fee_recipient.to_field(), user_point_slot, max_fee],\n        );\n    }\n    // docs:end:setup_refund\n\n    // TODO(#9375): Having to define the note log length here is very unfortunate as it's basically impossible for\n    // users to derive manually. This will however go away once we have a real transient storage since we will not need\n    // the public call and instead we would do something like `context.transient_storage_write(slot, payload)` and that\n    // will allow us to use generics and hence user will not need to define it explicitly. We cannot use generics here\n    // as it is an entrypoint function.\n    #[public]\n    #[internal]\n    fn _store_payload_in_transient_storage_unsafe(\n        slot: Field,\n        point: Point,\n        setup_log: [Field; 9],\n    ) {\n        context.storage_write(slot, point);\n        context.storage_write(slot + aztec::protocol_types::point::POINT_LENGTH as Field, setup_log);\n    }\n\n    // TODO(#7728): even though the max_fee should be a U128, we can't have that type in a contract interface due\n    // to serialization issues.\n    // docs:start:complete_refund\n    /// Executed as a public teardown function and is responsible for completing the refund in a private fee payment\n    /// flow.\n    #[public]\n    #[internal]\n    fn complete_refund(fee_recipient: AztecAddress, user_slot: Field, max_fee: Field) {\n        // TODO(#7728): Remove the next line\n        let max_fee = U128::from_integer(max_fee);\n        let tx_fee = U128::from_integer(context.transaction_fee());\n\n        // 1. We check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#7796): we should try to prevent reverts here\n        assert(max_fee >= tx_fee, \"max fee not enough to cover tx fee\");\n\n        // 2. We compute the refund amount as the difference between funded amount and the tx fee.\n        // TODO(#10805): Introduce a real exchange rate\n        let refund_amount = max_fee - tx_fee;\n\n        // 3. We send the tx fee to the fee recipient in public.\n        _increase_public_balance_inner(fee_recipient, tx_fee.to_field(), storage);\n\n        // 4. We construct the user note finalization payload with the refund amount.\n        let user_finalization_payload =\n            UintNote::finalization_payload().new(&mut context, user_slot, refund_amount);\n\n        // 5. At last we emit the user finalization note hash and the corresponding note log.\n        user_finalization_payload.emit();\n        // --> Once the tx is settled user and fee recipient can add the notes to their pixies.\n    }\n    // docs:end:complete_refund\n\n    /// Internal ///\n    // docs:start:increase_public_balance\n    /// TODO(#9180): Consider adding macro support for functions callable both as an entrypoint and as an internal\n    /// function.\n    #[public]\n    #[internal]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        _increase_public_balance_inner(to, amount, storage);\n    }\n    // docs:end:increase_public_balance\n\n    #[contract_library_method]\n    fn _increase_public_balance_inner(\n        to: AztecAddress,\n        amount: Field,\n        storage: Storage<&mut PublicContext>,\n    ) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n\n    // docs:start:reduce_total_supply\n    #[public]\n    #[internal]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n    // docs:start:balance_of_private\n    pub(crate) unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.at(owner).balance_of().to_field()\n    }\n    // docs:end:balance_of_private\n}\n\n// docs:end:token_all\n"
    },
    "354": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::partial_note,\n    note::utils::compute_note_hash_for_nullify,\n    oracle::random::random,\n    prelude::{NoteHeader, NullifiableNote, PrivateContext},\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator,\n    },\n};\n\n// docs:start:UintNote\n#[partial_note(quote {value})]\npub struct UintNote {\n    // The amount of tokens in the note\n    value: U128,\n    owner: AztecAddress,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n// docs:end:UintNote\n\nimpl NullifiableNote for UintNote {\n    // docs:start:nullifier\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl Eq for UintNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: U128, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness, header: NoteHeader::empty() }\n    }\n\n    pub fn get_value(self) -> U128 {\n        self.value\n    }\n}\n"
    },
    "359": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\npub(crate) global VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        /// Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        /// so a malicious sender could use non-random values to make the note less private. But they already know\n        /// the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        /// information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "51": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "52": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "57": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "62": {
      "path": "/Users/lago/Documents/joaolago1113/aztec_zk_rps/src/contracts/src/game_note.nr",
      "source": "use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n\nglobal GAME_NOTE_LEN: u32 = 7;\n\npub struct GameNote {\n    pub id: Field,\n    pub bet_amount: Field,\n    pub token_address: Field,\n    pub is_completed: bool,\n    pub blocktime: Field,\n    pub player2_address: Field,\n    pub player2_move: Field,\n}\n\nimpl GameNote {\n    pub fn new(id: Field, bet_amount: Field, token_address: Field) -> Self {\n        GameNote {\n            id,\n            bet_amount,\n            token_address,\n            is_completed: false,\n            blocktime: 0,\n            player2_address: 0,\n            player2_move: 0\n        }\n    }\n}\n\nimpl Serialize<GAME_NOTE_LEN> for GameNote {\n    fn serialize(self) -> [Field; GAME_NOTE_LEN] {\n        [\n            self.id,\n            self.bet_amount,\n            self.token_address,\n            self.is_completed as Field,\n            self.blocktime,\n            self.player2_address,\n            self.player2_move\n        ]\n    }\n}\n\nimpl Eq for GameNote {\n    fn eq(self, other: Self) -> bool {\n        self.id == other.id\n    }\n}\n\nimpl Deserialize<GAME_NOTE_LEN> for GameNote {\n    fn deserialize(fields: [Field; GAME_NOTE_LEN]) -> GameNote {\n        GameNote {\n            id: fields[0],\n            bet_amount: fields[1],\n            token_address: fields[2],\n            is_completed: fields[3] != 0,\n            blocktime: fields[4],\n            player2_address: fields[5],\n            player2_move: fields[6]\n        }\n    }\n}\n"
    },
    "63": {
      "path": "/Users/lago/Documents/joaolago1113/aztec_zk_rps/src/contracts/src/main.nr",
      "source": "mod game_note;\n\nuse dep::aztec::macros::aztec;\n\n/// An Aztec v3 Rock-Paper-Scissors contract with betting functionality.\n#[aztec]\ncontract RockPaperScissors {\n\n    use crate::game_note::GameNote;\n    use dep::aztec::{\n        encrypted_logs::{\n            encrypted_event_emission::encode_and_encrypt_event_unconstrained,\n            encrypted_note_emission::{\n                encode_and_encrypt_note_unconstrained,\n            },\n        },\n        note::{note_getter_options::NoteGetterOptions},\n        protocol_types::public_keys::OvpkM,\n        keys::getters::get_public_keys,\n        prelude::{PublicImmutable, AztecAddress, PrivateMutable, Map, PrivateSet, PrivateImmutable, PublicMutable, NoteHeader, Point},\n        encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n        macros::{storage::storage, storage::storage_no_init, functions::{private, public, initializer, internal}}\n    };\n    use dep::aztec::{note::note_getter_options::SortOrder, utils::comparison::Comparator};\n    use dep::token::Token;\n    use dep::value_note::value_note::ValueNote;\n    use aztec::oracle::random::random;\n\n    /// The contract's main storage structure.\n    #[storage]\n    struct Storage<Context> {\n        games_length: PublicMutable<Field, Context>,\n\n        plays: Map<Field, PrivateMutable<ValueNote, Context>, Context>,\n        games: Map<Field, PublicMutable<GameNote, Context>, Context>,\n        game_ids: Map<Field, PublicImmutable<Field, Context>, Context>,\n\n        owner: PublicImmutable<AztecAddress, Context>,\n        timeout_blocks: PublicMutable<Field, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(owner: AztecAddress, timeout_blocks: Field) {\n        storage.owner.initialize(owner);\n        storage.games_length.write(0);\n        storage.timeout_blocks.write(timeout_blocks);\n    }\n\n    #[public]\n    fn set_timeout_blocks(new_timeout: Field) {\n        assert(context.msg_sender() == storage.owner.read(), \"Only owner can set timeout blocks\");\n        storage.timeout_blocks.write(new_timeout);\n    }\n\n    #[private]\n    fn start_game(\n        game_id: Field,\n        player1_move: Field,\n        bet_amount: Field,\n        token_addr: Field\n    ) {\n        assert(player1_move as u8 <= 2, \"Invalid move!\");\n\n        let mut player_move_note = ValueNote::new(player1_move, context.msg_sender());\n\n        storage.plays.at(game_id).initialize(&mut player_move_note).emit(encode_and_encrypt_note_unconstrained(\n            &mut context,\n            context.msg_sender(),\n            context.msg_sender(),\n        ));\n\n        // Create and insert game note\n        let mut game_note = GameNote::new(\n            game_id,\n            bet_amount,\n            token_addr\n        );\n\n        RockPaperScissors::at(context.this_address())\n            ._add_game(context.msg_sender(), game_note)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _add_game(sender: AztecAddress, game_note: GameNote){\n\n        let current_length = storage.games_length.read();\n        storage.games_length.write(current_length + 1);\n\n        storage.game_ids.at(current_length).initialize(game_note.id);\n\n        storage.games.at(game_note.id).write(game_note);\n\n        Token::at(AztecAddress { inner: game_note.token_address })\n            .transfer_in_public(sender, context.this_address(), game_note.bet_amount, 0)\n            .call(&mut context);\n    }\n\n    #[public]\n    fn play_game(\n        game_id: Field,\n        player2_move: Field,\n        bet_match: Field\n    ) {\n        // Retrieve token address from the game note\n        let mut game_note = storage.games.at(game_id).read();\n        let token_addr = AztecAddress { inner: game_note.token_address };\n\n        Token::at(token_addr)\n            .transfer_in_public(context.msg_sender(), context.this_address(), bet_match, 0)\n            .call(&mut context);\n\n        game_note.player2_move = player2_move;\n        game_note.player2_address = context.msg_sender().to_field();\n        game_note.blocktime = context.block_number();\n\n        storage.games.at(game_id).write(game_note);\n    }\n\n    #[private]\n    fn resolve_game(game_id: Field) {\n        let play = storage.plays.at(game_id).get_note();\n        let player1_move = play.note.value;\n\n        RockPaperScissors::at(context.this_address())\n            ._resolve_game(game_id, player1_move, context.msg_sender())\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _resolve_game(game_id: Field, player1_move: Field, player1_address: AztecAddress) {\n        let mut game_note = storage.games.at(game_id).read();\n        assert(!game_note.is_completed, \"Game already completed\");\n\n        // Retrieve token address from the game note\n        let token_addr = AztecAddress { inner: game_note.token_address };\n        let player2_address = game_note.player2_address;\n\n        // Compare moves and determine winner\n        let p1 = player1_move;\n        let p2 = game_note.player2_move;\n        let bet_amount = game_note.bet_amount;\n\n        // Decide winner. 0=Rock,1=Paper,2=Scissors\n        let mut winner: AztecAddress = AztecAddress::zero();\n        let mut is_draw = false;\n\n        if p1 == p2 {\n            // It's a draw\n            is_draw = true;\n        } else {\n            // RPS logic: if (p1 + 1) mod 3 == p2 => p2 wins\n            let p1_plus_one = ((p1 + 1) as u32 % 3).to_field();\n            if p1_plus_one == p2 {\n                // Player2 wins\n                winner = AztecAddress { inner: player2_address };\n            } else {\n                // Player1 wins\n                winner = player1_address;\n            }\n        }\n\n        // Handle payouts\n        let pot = bet_amount * 2; // Total pot is 2x bet amount\n        \n        if is_draw {\n            // Return bets to both players\n            Token::at(token_addr)\n                .transfer_in_public(context.this_address(), player1_address, bet_amount, 0)\n                .call(&mut context);\n\n            Token::at(token_addr)\n                .transfer_in_public(context.this_address(), AztecAddress { inner: player2_address }, bet_amount, 0)\n                .call(&mut context);\n        } else {\n            // Send entire pot to winner\n            Token::at(token_addr)\n                .transfer_in_public(context.this_address(), winner, pot, 0)\n                .call(&mut context);\n        }\n\n        // Mark game as completed\n        game_note.is_completed = true;\n        storage.games.at(game_id).write(game_note);\n    }\n\n    #[public]\n    fn timeout_game(game_id: Field) {\n        let mut game_note = storage.games.at(game_id).read();\n        \n        // Check game isn't already completed\n        assert(!game_note.is_completed, \"Game already completed\");\n        \n        // Check player2 has made their move (blocktime will be non-zero)\n        assert(game_note.blocktime != 0, \"Player 2 hasn't played yet\");\n        \n        // Check if enough blocks have passed\n        let current_block = context.block_number();\n        let blocks_passed = current_block - game_note.blocktime;\n        let timeout_blocks = storage.timeout_blocks.read();\n        assert(blocks_passed as u32 > timeout_blocks as u32, \"Not enough blocks have passed for timeout\");\n\n        // Retrieve token address from the game note\n        let token_addr = AztecAddress { inner: game_note.token_address };\n        let bet_amount = game_note.bet_amount;\n        \n        // Award both bets to player 2 since player 1 timed out\n        let pot = bet_amount * Field::from(2);\n        Token::at(token_addr)\n            .transfer_in_public(context.this_address(), AztecAddress { inner: game_note.player2_address }, pot, 0)\n            .call(&mut context);\n\n        // Mark game as completed\n        game_note.is_completed = true;\n        storage.games.at(game_id).write(game_note);\n    }\n\n    #[public]\n    unconstrained fn get_game_by_id(game_id: Field) -> pub GameNote {\n        storage.games.at(game_id).read()\n    }\n\n    #[public]\n    unconstrained fn get_game_id_by_index(index: Field) -> pub Field {\n        storage.game_ids.at(index).read()\n    }\n\n    #[public]\n    unconstrained fn get_games_length() -> pub Field {\n        storage.games_length.read()\n    }\n\n    #[public]\n    unconstrained fn get_timeout_blocks() -> pub Field {\n        storage.timeout_blocks.read()\n    }\n\n}\n\n"
    },
    "64": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\npub struct PrivateCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args_hash: Field,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub gas_opts: GasOpts,\n    pub return_type: T,\n    pub is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: (),\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    pub target_contract: AztecAddress,\n    pub selector: FunctionSelector,\n    pub name: str<N>,\n    pub args: [Field],\n    pub return_type: T,\n    pub is_static: bool,\n    pub gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (),\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n        for i in 0..MaxLen {\n            if i >= len {\n                array[i] = zeroed;\n            }\n        }\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            /// Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            /// for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store_array(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store_array(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        /// Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        /// execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        /// the number of side effects that took place), along with the hash of the return values. We validate these\n        /// by requesting a private kernel iteration in which the return values are constrained to hash\n        /// to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store_array(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store_array(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store_array(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        /// Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        /// WARNING: This is insecure and should be temporary!\n        /// The oracle hashes the arguments and returns a new args_hash.\n        /// new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        /// We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        /// b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "72": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_unencrypted_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        /// Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            /// Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "74": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    encrypted_logs::payload::compute_private_log_payload,\n    note::{note_emission::NoteEmission, note_interface::NoteInterface},\n};\nuse dep::protocol_types::{\n    abis::note_hash::NoteHash, address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS,\n};\n\n/// Computes private note log payload\nfn compute_payload<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists =\n        context.note_hashes.storage().any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n\n    let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n    (payload, note_hash_counter)\n}\n\nunconstrained fn compute_payload_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> ([Field; PRIVATE_LOG_SIZE_IN_FIELDS], u32)\nwhere\n    Note: NoteInterface<N>,\n{\n    compute_payload(context, note, recipient, sender)\n}\n\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let (encrypted_log, note_hash_counter) =\n            compute_payload(*context, e.note, recipient, sender);\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    // We need this because to compute a tagging secret, we require a sender:\n    sender: AztecAddress,\n) -> fn[(&mut PrivateContext, AztecAddress, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        /// Safety:   Unconstrained logs have both their content and encryption unconstrained - it could occur that\n        /// the recipient is unable to decrypt the payload.\n        ///   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can\n        /// have more than one log and removes all of the matching ones, so all a malicious sender could do is\n        /// either: cause for the log to be deleted when it shouldn't have (which is fine - they can already make\n        /// the content be whatever), or cause for the log to not be deleted when it should have (which is also fine\n        /// - it'll be a log for a note that doesn't exist).\n        ///   It's important here that we do not return the log from this function to the app, otherwise it could\n        /// try to do stuff with it and then that might be wrong.\n        let (encrypted_log, note_hash_counter) =\n            unsafe { compute_payload_unconstrained(*context, e.note, recipient, sender) };\n        context.emit_raw_note_log(encrypted_log, note_hash_counter);\n    }\n}\n"
    },
    "78": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    point::Point,\n    public_keys::{IvpkM, ToPoint},\n    scalar::Scalar,\n};\n\nuse crate::keys::secret_derivation::derive_aes_secret;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    pub fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    pub fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = derive_aes_secret(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key)\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "80": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, hash::poseidon2_hash,\n    point::Point, public_keys::AddressPoint, scalar::Scalar, utils::arrays::array_concat,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe,\n};\n\nuse crate::{\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::secret_derivation::derive_aes_secret,\n    oracle::{\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        random::random,\n    },\n    utils::{bytes::bytes_to_fields, point::point_to_bytes},\n};\n\n// 1 field is reserved for tag.\nglobal ENCRYPTED_PAYLOAD_SIZE_IN_BYTES: u32 = (PRIVATE_LOG_SIZE_IN_FIELDS - 1) * 31;\n\ncomptime global HEADER_SIZE: u32 = 48;\n\n// Bytes padded to the overhead, so that the size of the incoming body ciphertext will be a multiple of 16.\ncomptime global OVERHEAD_PADDING: u32 = 15;\n\npub comptime global OVERHEAD_SIZE: u32 = 32 /* eph_pk */\n    + HEADER_SIZE /* incoming_header */\n    + OVERHEAD_PADDING /* padding */;\n\nglobal PLAINTEXT_LENGTH_SIZE: u32 = 2;\n\n// This is enough for 8 fields of data.\n// 1 field for storage slot, 1 field for note/event type id, allowing 6 fields for custom values.\nglobal MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 =\n    ENCRYPTED_PAYLOAD_SIZE_IN_BYTES - OVERHEAD_SIZE - PLAINTEXT_LENGTH_SIZE - 1 /* aes padding */;\n\n// Note: Might have to update PRIVATE_LOG_SIZE_IN_FIELDS in `constants.nr` if the above changes.\n// This value ideally should be set by the protocol, allowing users (or `aztec-nr`) to fit data within the defined size limits.\n// Currently, we adjust this value as the structure changes, then update `constants.nr` to match.\n// Once the structure is finalized with defined overhead and max note field sizes, this value will be fixed and should remain unaffected by further payload composition changes.\n\npub fn compute_private_log_payload<let P: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    assert(\n        P < MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n        f\"plaintext for log must not exceed {MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES}\",\n    );\n\n    let extended_plaintext: [u8; MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; ENCRYPTED_PAYLOAD_SIZE_IN_BYTES] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    array_concat([tag], bytes_to_fields(encrypted))\n}\n\npub fn compute_partial_public_log_payload<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    sender: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let extended_plaintext: [u8; P + PLAINTEXT_LENGTH_SIZE] =\n        extend_private_log_plaintext(plaintext);\n    let encrypted: [u8; M - 32] =\n        compute_encrypted_log(contract_address, recipient, extended_plaintext);\n\n    /// Safety: We assume that the sender wants for the recipient to find the tagged note, and therefore that they\n    /// will cooperate and use the correct tag. Usage of a bad tag will result in the recipient not being able to\n    /// find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n    // Silo the tag with contract address.\n    // This is done by the kernel circuit to the private logs, but since the partial log will be finalized and emitted\n    // in public as unencrypted log, its tag is not siloed at the moment.\n    // To avoid querying logs using two types of tags, we silo the tag manually here.\n    // TODO(#10273) This should be done by the AVM when it's processing the raw logs instead of their hashes.\n    let siloed_tag_bytes: [u8; 32] =\n        poseidon2_hash([contract_address.to_field(), tag]).to_be_bytes();\n\n    // Temporary hack so that the partial public log remains the same format.\n    // It should return field array and make the tag the first field as compute_private_log_payload does.\n    let mut log_bytes = [0; M];\n    for i in 0..32 {\n        log_bytes[i] = siloed_tag_bytes[i];\n    }\n    for i in 0..encrypted.len() {\n        log_bytes[i + 32] = encrypted[i];\n    }\n\n    log_bytes\n}\n\nfn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] =\n        header.compute_ciphertext(eph_sk, recipient.to_address_point());\n    let incoming_body_ciphertext =\n        compute_incoming_body_ciphertext(plaintext, eph_sk, recipient.to_address_point());\n\n    let mut encrypted_bytes = [0; M];\n    let mut offset = 0;\n\n    // eph_pk\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[offset + i] = eph_pk_bytes[i];\n    }\n    offset += 32;\n\n    // incoming_header\n    for i in 0..HEADER_SIZE {\n        encrypted_bytes[offset + i] = incoming_header_ciphertext[i];\n    }\n    offset += HEADER_SIZE;\n\n    // Padding.\n    offset += OVERHEAD_PADDING;\n\n    // incoming_body\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - offset;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    // Nargo seems to struggle with realizing that `offset` is a constant at this point.\n    // We then redefine it in terms of the assertion above to give nargo a hint.\n    let offset = M - incoming_body_ciphertext.len();\n    for i in 0..size {\n        encrypted_bytes[offset + i] = incoming_body_ciphertext[i];\n    }\n\n    encrypted_bytes\n}\n\n// Prepend the plaintext length as the first byte, then copy the plaintext itself starting from the second byte.\n// Fill the remaining bytes with random values to reach a fixed length of N.\nfn extend_private_log_plaintext<let P: u32, let N: u32>(plaintext: [u8; P]) -> [u8; N] {\n    /// Safety: A malicious sender could reveal the whole contents of the encrypted log so trusting it to set\n    /// a random padding in plaintext is fine.\n    let mut padded = unsafe { get_random_bytes() };\n    padded[0] = (P >> 8) as u8;\n    padded[1] = P as u8;\n    for i in 0..P {\n        padded[i + PLAINTEXT_LENGTH_SIZE] = plaintext[i];\n    }\n    padded\n}\n\nunconstrained fn get_random_bytes<let N: u32>() -> [u8; N] {\n    let mut bytes = [0; N];\n    let mut idx = 32;\n    let mut randomness = [0; 32];\n    for i in 0..N {\n        if idx == 32 {\n            randomness = random().to_be_bytes();\n            idx = 1; // Skip the first byte as it's always 0.\n        }\n        bytes[i] = randomness[idx];\n        idx += 1;\n    }\n    bytes\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    /// Safety: We use the randomness to preserve the privacy of both the sender and recipient via encryption, so\n    /// a malicious sender could use non-random values to reveal the plaintext. But they already know it themselves\n    /// anyway, and so the recipient already trusts them to not disclose this information. We can therefore assume\n    /// that the sender will cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    address_point: AddressPoint,\n) -> [u8; P + 16 - P % 16] {\n    let full_key = derive_aes_secret(eph_sk, address_point.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_incoming_body_ciphertext, compute_private_log_payload,\n        MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES,\n    };\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use protocol_types::public_keys::AddressPoint;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_log_payload.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(\n            (MAX_PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES as u64 + 1 + 30) / 31,\n        );\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        let payload = compute_private_log_payload(contract_address, recipient, sender, plaintext);\n\n        // The following value was generated by `encrypted_log_payload.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let private_log_payload_from_typescript = [\n            0x0e9cffc3ddd746affb02410d8f0a823e89939785bcc8e88ee4f3cae05e737c36,\n            0x008d460c0e434d846ec1ea286e4090eb56376ff27bddc1aacae1d856549f701f,\n            0x00a70577790aeabcc2d81ec8d0c99e7f5d2bf2f1452025dc777a178404f851d9,\n            0x003de818923f85187871d99bdf95d695eff0a900000000000000000000000000,\n            0x000000a600a61f7d59eeaf52eb51bc0592ff981d9ba3ea8e6ea8ba9dc0cec8c7,\n            0x000b81e84556a77ce6c3ca47a527f99ffe7b2524bb885a23020b7295748ad19c,\n            0x001083618ad96298b76ee07eb1a56d19cc798710e9f5de96501bd59b3781c9c0,\n            0x002a6c95c5912f8936b1500d362afbf0922c85b1ada18db8b95162a6e9d06765,\n            0x005cdf669eb387f8e0492a95fdcdb39429d5340b4bebc250ba9bf62c2f49f549,\n            0x00f37beed75a668aa51967e0e57547e5a655157bcf381e22f30e25881548ec96,\n            0x0006a151b5fbfb2d14ee4b34bf4c1dbd71c7be15ad4c63474bb6f89970aeb3d9,\n            0x00489c8edbdff80a1a3a5c28370e534abc870a85ea4318326ea19222fb10df35,\n            0x008c765edada497db4284ae30507a2e03e983d23cfa0bd831577e857bbef9cf7,\n            0x0090c97cb5699cc8783a1b4276d929be2882e5b9b72829a4f8404f7e3c853d11,\n            0x00d6d5a000b80134891e95f81007ad35d3945eaeecbe137fff85d01d7eaf8f19,\n            0x00a15eb965c6a4bc97aa87fd3463c31c9d4e0d722a8ba870bcc50c9c7a8b48ad,\n            0x0063c861bdbe490d44c57382decbae663927909652f87ac18dcfd5b30649cce5,\n            0x00820f14caa725efe1fa3485ceac88499eadf0565c5b20998c05931bbf478e68,\n        ];\n\n        assert_eq(payload, private_log_payload_from_typescript);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let address_point = AddressPoint {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `address_point` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, address_point);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n}\n"
    },
    "84": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "93": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    /// Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "96": {
      "path": "/Users/lago/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.71.0/noir-projects/aztec-nr/aztec/src/keys/secret_derivation.nr",
      "source": "use crate::utils::point::point_to_bytes;\nuse dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, point::Point, scalar::Scalar};\nuse std::{embedded_curve_ops::multi_scalar_mul, hash::sha256};\n\npub fn derive_aes_secret(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret = point_to_bytes(multi_scalar_mul([point], [secret]));\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret[i];\n    }\n\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/10537): Replace use of sha256\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_derive_aes_secret_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = derive_aes_secret(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    }
  }
}
